\documentclass[]{article}

% Package `amsthm` and `thmtools` must come before package `hyperref`.
\usepackage{amsthm}
\usepackage{thmtools}
% Package `hyperref` must come before package `complexity`.
\usepackage[pdftitle={Restricted probabilistically checkable proofs}, pdfauthor={Jeffrey Finkelstein}]{hyperref}
\usepackage{complexity}
\usepackage{amsmath}
\usepackage{amssymb}

\declaretheorem[numberwithin=section]{theorem}
\declaretheorem[numberlike=theorem]{corollary}
\declaretheorem[numberlike=theorem]{lemma}
\declaretheorem[numberlike=theorem]{proposition}
\declaretheorem[numberlike=theorem, style=definition]{construction}
\declaretheorem[numberlike=theorem, style=definition]{definition}

%% Arguments:
%%  1. Complexity class of the verifier
%%  2. Completeness probability
%%  3. Soundness probability
%%  4. Randomness
%%  5. Number of queries
\newcommand{\PCPcs}[5]{\PCP^{#1}_{#2, #3}\left[#4, #5\right]}
\newcommand{\lglg}{\lg\lg}
\newcommand{\email}[1]{\href{mailto:#1}{\nolinkurl{#1}}}

\newenvironment{proofidea}{\begin{proof}[Proof~idea]}{\end{proof}}

\title{Restricted probabilistically checkable proofs}
\author{Jef{}frey~Finkelstein}
\date{\today}

\begin{document}
\maketitle

\section{Introduction}

In this work we provide some initial structural complexity results for classes of probabilistically checkable proof systems (PCPs) for nondeterministic \NC{} (\NNC) circuit families, as a first step towards characterizing probabilistic proof systems for \P.
One of the major successes of the characterization of \NP{} as a class of PCPs (with polynomial time verifiers) is that it provides a route to proving that approximating certain computationally intractable optimization problems is as difficult as solving them exactly.
The growth of multiprocessor systems in general purpose personal computers highlights the urgency of proving the analagous inapproximability (or approximability) of \emph{inherently sequential} optimization problems by \emph{highly parallel} algorithms.
The \P-complete problems are generally considered to be inherently sequential, whereas problems in \NC{} are considered highly parallel.
Our guiding question is now, ``For which \P-complete problems are there \NC{} approximation algorithms, and for which are there none?''

Unfortunately, the techniques used to prove the original PCP Theorem rely on the fact that \NP{} can be interpreted as the class of languages for which there is an efficient verification procedure given a brief witness to language membership; no such obvious interpretation of \P{} exists.
Indeed, this question was already on the minds of researchers soon after the original proof of the PCP Theorem.
\begin{quote}
  An intriguing question is whether the known non-approximability results for sequential algorithms can be improved when we restrict to \NC{} algorithms (under the assumption that $\P \neq \NC$).
  A possible way may be to devise \emph{probabilistic proof systems for \P} more efficient that the currently known proof systems for \NP.
  Such a result would have a great independent interest.
  However, it is not clear why proofs for \P{} should be \emph{easier to check} than proofs for \NP{} (they only appear to be \emph{easier to generate}). \cite{trevisan98}
\end{quote}
Perhaps \P{} has proof systems which are easy to check in \NC, but this remains unclear.
Instead, we consider proof systems for the class $\NNC(\polylog)$, the class of languages decidable by \NC{} circuit families augmented with a polylogarithmic number of nondeterministic gates.
We hope that this will be a valuable first step toward understanding proof systems for \P.
We consider $\NNC(\polylog)$ for two reasons.
First, it is defined in such a way that it explicitly has short proof systems which are easy to verify in parallel, just as \NP{} is defined in such a way that it explicitly has short proof systems which are easy to verify efficiently.
Second, it, like \P, lies between \NC{} and \NP{}.

Although our original intention was to show a result like $\NNC(\polylog) = \PCP[O(\lg \lg n), O(1)]$, our research reveals that proving such an equality is equivalent to proving $\NNC(\polylog) = \NC$, or in other words, that a polylogarithmic amount of nondeterminism can be simulated deterministically by an \NC{} circuit family.
This should be seen as evidence that such a result is unlikely; in fact, we show that such a simulation implies a deterministic subexponential time algorithm for \textsc{Satisfiability}!
We are still, however, able to show that certain PCP classes are contained in $\NNC(\polylog)$.

\section{Preliminaries}

\begin{definition}
  For all functions $f, g \colon \mathbb{N} \to \mathbb{R}$, the function $f$ is in the class $O(g(n))$ if there exist real numbers $c$ and $N$ such that for all natural numbers $n$ we have $n > N$ implies $f(n) \leq c \cdot g(n)$.
  If $f(n) < c \cdot g(n)$ then $f(n)$ is in $o(g(n))$.
\end{definition}

\begin{definition}[{{\cite[Definition~1.1]{dinur07}}}]
  Let $V$ be a finite set of variables, defined by $V = \{x_1, x_2, \dotsc, x_n\}$, let $\Gamma$ be a finite alphabet, and let $q$ be a natural number.
  A \emph{$q$-ary constraint} is a $q + 1$ tuple, $(C, i_1, i_2, \dotsc, i_q)$, where $C \subseteq \Gamma^q$ and $i_k \in \{1, 2, \dotsc, n\}$ for all $k \in \{1, 2, \ldots, q\}$.
  Here, $C$ is considered the set of ``acceptable'' values for the variables.

  An \emph{assignment} is a function $a \colon V \to \Gamma$.
  An assignment \emph{satisfies} a constraint if $(a(v_{i_1}), a(v_{i_2}), \dotsc, a(v_{i_q})) \in C$.
\end{definition}

\begin{definition}[\textsc{$\frac{1}{2}$-gap $q$-CSP}]
  \mbox{}

  \textbf{Instance:} finite alphabet $\Gamma$ with $|\Gamma| > 1$, finite set of variables $V$, finite set of $q$-ary constraints $D$ with the restriction that for any assignment, either all constraints are satisfied or fewer than half are.

  \textbf{Question:} Are all constraints in $D$ satisfiable?
\end{definition}

\begin{definition}
  A \emph{PCP verifier} is a probabilistic Turing machine which has sequential access to an input string $x$, sequential access to a random string $\rho$, and \emph{nonadaptive random access} to a proof string $\pi$.
\end{definition}

The initialism ``PCP'' stands for ``probabilistically checkable proof''.

\begin{definition}
  Let $r(n)$ and $q(n)$ be bounded above by polynomials in $n$, and let $c(n)$ and $s(n)$ be functions whose values are in the interval $[0, 1]$.
  A language $L$ has a $(r(n), q(n), c(n), s(n))$-\emph{PCP verifier} if there exists a PCP verifier $V$ such that $V$ uses at most $r(n)$ bits of the random string $\rho$, makes at most $q(n)$ \emph{nonadaptive} queries to bits of the proof $\pi$, and satisfies the following conditions.
  \begin{enumerate}
  \item If $x \in L$, then
    \begin{equation*}
      \exists \pi \in \Sigma^* \colon \Pr_{\rho \in \Sigma^{r(n)}}{\left[V(x, \pi; \rho) \textnormal{ accepts}\right]} \geq c(n).
    \end{equation*}
  \item If $x \notin L$, then
    \begin{equation*}
      \forall \pi \in \Sigma^* \colon \Pr_{\rho \in \Sigma^{r(n)}}{\left[V(x, \pi; \rho) \textnormal{ accepts}\right]} < s(n).
    \end{equation*}
  \end{enumerate}
  The value $c(n)$ is the \emph{completeness} and the value $s(n)$ the \emph{soundness} of the verifier.
\end{definition}

In this work, we will consider only nonadaptive PCP verifiers.
Since a (nonadaptive) $(r(n), q(n), c(n), s(n))$-PCP verifier can read at most $2^{r(n)} q(n)$ locations of the proof string with nonzero probability, we assume without loss of generality that the proof provided to the verifier is of length at most $2^{r(n)} q(n)$ \cite[Remark~11.6]{ab09}.
(Note that a verifier which uses $q(n)$ adaptive random access queries to the proof string can be simulated by a verifier which uses $2^{q(n)}$ nonadaptive random access queries to the proof string, so in the adaptive case, the proof string could be of length $2^{r(n) + q(n)}$.)

\begin{definition}
  Let $\PCPcs{\mathcal{C}}{c(n)}{s(n)}{r(n)}{q(n)}$ be the class of all languages $L$ such that $L$ has a $(r(n), q(n), c(n), s(n))$-PCP verifier $V$ computable by a $\mathcal{C}$ algorithm.

  More generally, if $\mathcal{F}$ and $\mathcal{G}$ are classes of functions,
  \begin{equation*}
    \PCPcs{\mathcal{C}}{c(n)}{s(n)}{\mathcal{F}}{\mathcal{G}} = \bigcup_{f \in \mathcal{C}, g \in \mathcal{G}}{\PCPcs{\mathcal{C}}{c(n)}{s(n)}{f(n)}{g(n)}},
    \end{equation*}

  Since completeness 1 and soundness $\frac{1}{2}$ are common parameters, and for the sake of brevity, we write $\PCP^{\mathcal{C}}[r(n), q(n)]$ to denote $\PCPcs{\mathcal{C}}{1}{\frac{1}{2}}{r(n)}{q(n)}$, and $\PCP^{\mathcal{C}}[\mathcal{F}, \mathcal{G}]$ to denote $\PCPcs{\mathcal{C}}{1}{\frac{1}{2}}{\mathcal{F}}{\mathcal{G}}$.
\end{definition}

Please notice that the complexity class given in the superscript in the above definition does \emph{not} denote an oracle; it merely describes the computational power of the PCP verifier.

From the definition, we see immediately that
\begin{equation*}
  \PCPcs{\mathcal{C}}{c(n)}{s{n}}{O(r(n))}{O(q(n))} = \bigcup_{a \in \mathbb{N}, b \in \mathbb{N}}{\PCPcs{\mathcal{C}}{c(n)}{s(n)}{a \cdot r(n)}{b \cdot q(n)}}.
\end{equation*}

\section{Nondeterministic \texorpdfstring{\NC}{NC} circuits and polynomial time}\label{sec:nnc}

As stated in the introduction, we are motivated by the search for a reasonable model of a proof system for \P{} in which the verifier is an \NC{} circuit.
Unlike \P{} and \NP{}, the classes \NC{} and \P{} are not related by definition.
However, the analogous relationship does hold for \NC{} and a nondeterministic generalization of \NC{}.
\begin{definition}
  A \emph{nondeterministic gate} (or \emph{guess gate}) in a Boolean circuit is a gate with no inputs and one output.
  A language $L$ is in $\NNC(f(n))$ if there exists an \NC{} circuit family $\left\{C_n\right\}_{n \in \mathbb{N}}$, each circuit $C_n$ augmented with $O(f(n))$ nondeterministic guess gates, such that $x \in L$ if and only if $C_n(x)$ accepts.

  As an alternative definition, a language $L$ is in $\NNC(f(n))$ if there exists an \NC{} circuit family $\left\{C_N\right\}_{N \in \mathbb{N}}$ such that for all strings $x$ of length $n$, we have $x \in L$ if and only if there exists a constant $c$ and a witness $\pi$ of length $c \cdot f(n)$ such that $C_{n + c \cdot f(n)}(x, \pi)$ outputs 1.
\end{definition}

\begin{proposition}[\cite{wolf94}]\label{prop:nnc}
  \mbox{}
  \begin{enumerate}
  \item $\NNC(\lg n) = \NC$.
  \item $\NNC(\poly) = \NP$, and specifically $\NP \subseteq \NNC^1(\poly)$.
  \end{enumerate}
\end{proposition}

The above proposition suggests that $\NNC(\polylog)$, which resides between \NC{} and \NP, may have computational power roughly comparable to that of \P.
In \cite{wolf94}, the author conjectures that $\NNC(\polylog)$ is incomparable with $\P$, in the sense that neither is a subset of the other.
We can get some of idea of the relationship between $\NNC(\polylog)$ and $\P$ from the following theorems.

\begin{lemma}[{\cite[Lemma~3.1 and Lemma~3.3]{wolf94}}]\label{lem:dspace}
  For all $k, j \in \mathbb{Q}$ with $k \geq 1$ and $j \geq 1$,
  \begin{enumerate}
  \item $\NNC^k(\lg^j n) \subseteq \DSPACE(\lg^{\max(k, j)} n)$ and
  \item $\NNC^k(n^j) \subseteq \DSPACE(n^j)$.
  \end{enumerate}
\end{lemma}

$\NNC^k(\lg^d n)$ has complete problems under logarithmic space many-one reductions \cite[Theorem~3.6]{cc97}, so that part of the hypothesis in item 2 of the next proposition makes sense.

\begin{proposition}
  For all integers $k$ and $d$,
  \begin{enumerate}
  \item if a language $L$ is hard for $\NNC^k(\lg^d n)$ under $\leq_m^P$ reductions and $L \in \P$ then $\NNC^k(\lg^d n) \subseteq \P$, and
  \item if a language $L$ is hard for $\P$ under $\leq_m^{NC^k}$ reductions and $L \in \NNC^k(\lg^d n)$ then $\P \subseteq \NNC^k(\lg^d n)$.
    Furthermore $\P \subsetneq \polyL$.
  \end{enumerate}
\end{proposition}
\begin{proof}
  A standard simulation argument proves both statements.
  Since we have $\NNC^k(\lg^d n) \subseteq \DSPACE(\lg^m)$, where $m = \max(k, d)$, by \autoref{lem:dspace} and $\P \neq \polyL$ (by the Space Hierarchy Theorem), we conclude that $\P \subsetneq \polyL$.
\end{proof}

A natural next question is whether $\NNC(\log^k n) \subsetneq \NNC(\log^{k + 1} n)$.
One way to make progress toward such a claim is to determine whether the $\NNC(\polylog)$ hierarchy exhibits the ``upward collapse'' (or equivalently, ``downward separation'') property.
An upward collapse property for a hierarchy of complexity classes $\mathcal{C}_1 \subseteq \mathcal{C}_2 \subseteq \dotsb \subseteq \cup_k \mathcal{C}_k$ is a theorem of the form ``if $\mathcal{C}_k = \mathcal{C}_{k + 1}$ then $\mathcal{C}_k = \cup_{j > k} \mathcal{C}_j$'', where the conclusion of the implication is some collapse which is considered unlikely.
For example, the polynomial hierarchy exhibits this property: if $\SKP = \SKPOP$ then $\SKP = \PH$.
In fact, the (deterministic) $\NC^d$ hierarchy itself (that is, $\NC^1 \subseteq \NC^2 \subseteq \dotsb \subseteq \NC$) has this property \cite[Corollary~5]{wilson89}.
Upward collapse can be seen as evidence that each of the inclusions in the hierarchy is strict.
Unfortunately, there can be no relativizing proof that the $\NP[\polylog]$ hierarchy exhibits upward collapse \cite{bg94}, where $\NP[\polylog]$ is the polynomial time analog of $\NNC(\polylog)$.
The same likely holds for $\NNC(\polylog)$ (\textbf{TODO show that a similar proof gives the same property for NNC(polylog).}...

What we can say, however, is that a collapse in the $\NNC(\polylog)$ hierarchy corresponds to a subexponential time algorithm for \textsc{Satisfiability}.
We adapt to our setting the analagous theorem and proof for the $\NP[\polylog]$ hierarchy found in \cite[Theorem~1]{dt90} (therein attributed to Beigel).
\begin{theorem}\label{thm:collapse}
  For all positive integers $k$ and all positive integers $i$ and $j$ where $i < j$, if $\NNC^k(\log^i n) = \NNC^k(\log^j n)$ then $\NP \subseteq \DTIME(2^{o(n)})$.
\end{theorem}
\begin{proof}
  Since \textsc{Satisfiability} is complete for $\NP$ under deterministic polynomial time many-one reductions, it suffices to show a $2^{o(n)}$ time algorithm for \textsc{Satisfiability}.

  The proof uses a padding argument.
  First we observe that there is an $\NNC^1(n)$ machine, call it $M$, that decides \textsc{Satisfiability}: given a Boolean formula $\phi$, guess a satisfying assignment to $\phi$ (of length $O(n)$) and evaluate the formula (Boolean formula evaluation is in $\NC^1$ \cite{buss87}).
  Define $L'$, the padded version of \textsc{Satisfiability}, as
  \begin{equation*}
    L = \left\{ \phi \# 1^P \, \middle| \, \phi \in \textsc{Satisfiability} \text{ and } P = 2^{n^\frac{1}{j}} - (n + 1) \right\},
  \end{equation*}
  where $n = |\phi|$.
  We claim $L$ is in $\NNC^k(\log^j n)$ by the following algorithm.
  On input $\phi'$, check that $\phi'$ is in the format $\phi \# 1^P$, then accept if and only if $M$ accepts $\phi$.
  This algorithm, call it $M_j$, is correct if $M$ is correct (and it is), so it remains to check the size and depth of the circuit for $M_j$, and the amount of nondeterminism used.

  Checking that $x'$ is in the correct format can be performed (deterministically) by an $\NC^0$ circuit by computing the conjunction of all the bits after the $\#$ symbol.
  Observe now that $|x'| = 2^{n^{\frac{1}{j}}}$, so $n = \log^j{|x'|}$.
  The amount of nondeterminism used by $M_j$ is the same as the amount used by $M$, which is $O(n)$, or $O(\log^j |x'|)$.
  The size of $M$ is polynomial in $n$, which is polylogarithmic in $|x'|$, and hence polynomial in the length of the input $x'$.
  The depth of $M$ is $O(\log n)$, which is $O(\log \log^j |x'|)$, or simply $O(\log \log |x'|)$.
  We conclude that the size of $M_j$ is polynomial in $|x'|$, the depth of $M_j$ is logarithmic in $|x'|$, and $M_j$ uses $O(\log^j |x'|)$ bits of nondeterminism.
  Hence $L$ is in $\NNC^1(\log^j n)$, and more generally, in $\NNC^k(\log^j n)$.

  By hypothesis, $L$ is also in $\NNC^k(\log^i n)$.
  Let $M_i$ be the $\NNC^k(\log^i n)$ machine that decides it.
  We claim that we can now construct a subexponential time algorithm for \textsc{Satisfiability} on inputs $\phi$ of length $n$.
  \begin{enumerate}
  \item Let $\phi' = \phi \# 1^P$, where $P = 2^{n^{\frac{1}{j}}} - (n + 1)$.
  \item Accept if and only if $M_i$ accepts $\phi'$.
  \end{enumerate}
  The correctness of this algorithm follows immediately from the correctness of $M_i$.
  The first step can be performed by a deterministic algorithm running in time $2^{n^{\frac{1}{j}}}$.
  The second step can be performed by an $\NNC^k(\log^i n)$ algorithm on inputs of length $n$.
  However, the length of the input to $M_i$ is actually $2^{n^{\frac{1}{j}}}$, so
  \begin{align*}
    \NNC^k(\log^i{2^{n^{\frac{1}{j}}}}) & = \NNC^k(n^{\frac{i}{j}}) & \\
    & \subseteq \DSPACE(n^{\frac{i}{j}}) & \text{(by \autoref{lem:dspace})} \\
    & \subseteq \DTIME(2^{n^{\frac{i}{j}}}) & \text{(by exhaustive search)} \\
    & \subseteq \DTIME(2^{o(n)}) & \text{(because } i < j \text{).}
  \end{align*}
  Hence the second step can be performed by a deterministic algorithm running in time $2^{n^{\frac{i}{j}}}$.
  Therefore, this algorithm for \textsc{Satisfiability} can be implemented by a deterministic algorithm running in $2^{o(n)}$ time.
\end{proof}

This theorem will be used after proving \autoref{thm:equiv} to provide evidence that the techniques used to construct a PCP characterization of $\NP$ likely do not translate to providing a similar characterization for $\NNC(\polylog)$.

\section{Probabilistically checkable proofs for \texorpdfstring{\NP}{NP}}

We begin our study of probabilistically checkable proofs for efficiently decidable languages by recalling some of the basic techniques from the study of probabilistically checkable proofs for efficiently verifiable languages.
The celebrated ``PCP Theorem'' can be stated as follows.

\begin{theorem}[PCP Theorem]
  $\NP = \PCP^\P[O(\lg n), O(1)]$.
\end{theorem}

The proof has two parts, one easy and one hard.
The following lemma proves the easy part.

\begin{lemma}\label{lem:pcpinnp}
  $\PCP^\P[O(\lg n), O(1)] \subseteq \NP$.
\end{lemma}
\begin{proof}
  Let $L \in \PCP^\P[O(\lg n), O(1)]$, so there exists a polynomial time PCP verifier $V$ subject to the appropriate restrictions.
  Construct a nondeterministic Turing machine $N$ as follows.

  On input $x$, nondeterministically guess a proof string $\pi$ of length $2^{r \lg n + \lg q}$, where $q$ and $r$ are the appropriate constants for the language $L$.
  Enumerate each ``random'' string $\rho$ of length $r \lg  n$, and for each $\rho$, simulate $V$ on input $x$, proof string $\pi$, and random string $\rho$.
  If $V$ accepts in at least half of the simulations, then accept; otherwise reject.

  This machine uses a polynomial amount of nondeterminism, runs in polynomial time (due to the fact that $V$ runs in polynomial time, and counting the number of accepting simulations can also be performed efficiently) and accepts exactly when at least half of the instances of $V(x, \pi; \rho)$ accept.
  Therefore $x \in L$ if and only $N$ accepts $x$, and we have $L \in \NP$.  
\end{proof}

The hard part uses the following ``inapproximability'' view of the PCP Theorem.
\begin{proposition}[{{\cite[Theorem~1.3]{dinur07}}}]\label{prop:equivalence}
  The following are equivalent.
  \begin{enumerate}
  \item $\NP \subseteq \PCP^\P[O(\lg n), O(1)]$.
  \item There exists an integer $q$, with $q > 1$, such that \textsc{$\frac{1}{2}$-gap $q$-CSP} is \NP-hard.
  \end{enumerate}
\end{proposition}

Before proving this proposition, we provide one part of it as a separate lemma, because it will be of use in later theorems.

\begin{lemma}\label{lem:constraintsp}
  If $L \in \PCP^\P[O(\lg n), O(1)]$ then there is a $\leq_m^P$ reduction from $L$ to \textsc{$\frac{1}{2}$-gap $q$-CSP}, for some integer $q$ greater than 1.
\end{lemma}
\begin{proof}
  Let $L$ be a language in $\PCP^\P[O(\lg n), O(1)]$.
  Let $V$ be the polynomial time PCP verifier for $L$ which uses $r \lg n$ bits of randomness and queries $q$ bits of the proof string, for some constants $r$ and $q$.
  Consider the Cook-Levin transformation of the operation of $V$ into a Boolean circuit; the circuit will have input variables representing the bits of the input $x$, the bits of the random string $\rho$, and the bits of the proof string $\pi$.
  For each fixed input $x$ of length $n$ and each fixed $\rho \in \Sigma^{r \lg n}$, simplify the circuit based on the values (that is, the 0s and 1s) of the variables corresponding to $x$ and the variables corresponding to $\rho$ into a Boolean function (also called a Boolean constraint) which depends only on the bits of the proof string $\pi$.
  Let $\phi_{x, \rho}$ be that Boolean constraint; note that it depends only on $q$ Boolean variables.
  Let $U_{x, \rho}$ be the variables corresponding to the bits of the proof string $\pi$ queried by $V$ on input $x$ and random string $\rho$.

  Now we construct a reduction from $L$ to \textsc{$\frac{1}{2}$-gap $q$-CSP}.
  Define the reduction $f$ by $f(x) = (\Gamma, U, D)$, where
  \begin{align*}
    \Gamma & = \{0, 1\}, \\
    U & = \bigcup_{\rho \in \Sigma^{r \lg n}}{U_{x, \rho}}, \text{ and} \\
    D & = \left\{\phi_{x, \rho}\right\}_{\rho \in \Sigma^{r \lg n}}.
  \end{align*}
  $f(x)$ is polynomial time computable (there are $qn^r$ variables in $U$ and $n^r$ constraints in $D$, both polynomials in $n$).
  By the correctness of the Cook-Levin reduction and by the completeness and soundness of the PCP verifier if $x \in L$ then there exists a $\pi$ such that for all strings $\rho$, we have $V(x, \rho; \pi)$ accepts and hence all the constraints are satisfiable.
  Furthermore, if $x \notin L$ then for all $\pi$, on less than half of the strings $\rho$ will $V(x, \pi; \rho)$ accept, so less than half of the constraints will be satisfiable.
  Therefore we have shown a correct polynomial time reduction from $L$ to \textsc{$\frac{1}{2}$-gap $q$-CSP}.
\end{proof}

\begin{proof}[Proof of \autoref{prop:equivalence}]
  One direction of the equivalence follows immediately from the inclusion in the hypothesis and from \autoref{lem:constraintsp}.
  Thus it suffices to prove the converse implication.
  Suppose \textsc{$\frac{1}{2}$-gap $q$-CSP} is \NP-hard for some $q$ greater than 1.
  Let $L$ be a language in \NP.
  By hypothesis there exists a (deterministic) polynomial time computable reduction from $L$ to \textsc{$\frac{1}{2}$-gap $q$-CSP}.
  Construct the PCP verifier as follows.
  \begin{enumerate}
  \item Compute the reduction to produce a set of constraints.
  \item Use $O(\lg n)$ random bits to choose a constraint uniformly at random.
  \item Check that the constraint is satisfied by querying the proof string at the appropriate locations (the locations corresponding to the $q$ variables in the constraint).
  \end{enumerate}

  If $x \in L$ then all constraints are satisfiable, so there exists an assignment such that the verifier will accept on all random choices of the constraint.
  If $x \notin L$ then fewer than half of the constraints are satisfiable, so for any assignment the probability that the verifier will select a satisfied constraint is less than half.
  Therefore we have shown a correct PCP verifier with the appropriate parameters for an arbitrary language in \NP.
\end{proof}
With this equivalence, we can reduce the problem of showing that $\NP \subseteq \PCP^\P[O(\lg n), O(1)]$ to the problem of showing that \textsc{$\frac{1}{2}$-gap $q$-CSP} is \NP-hard.
An almost entirely combinatoric approach can solve the latter problem \cite{dinur07}.

We will scale down the techniques from the proofs of \autoref{lem:pcpinnp} and \autoref{prop:equivalence} to prove analogous results in \autoref{sec:nncinpcp} and \autoref{sec:pcpinnnc}, respectively.

\section{Nondeterministic \texorpdfstring{\NC}{NC} circuits for probabilistically checkable proof systems}\label{sec:nncinpcp}

As stated in the introduction, our motivation is to characterize \P{} using PCP classes which are more restrictive than the ones defined in the traditional way, and our first attempt at such a characterization involves the use $\NNC(\polylog)$ in place of \P.
We hope to use such a characterization for applications to inapproximability in the realm of optimization problems whose corresponding decision problems are \P-complete, but which admit a ``good'' highly parallel approximation.
In this work, ``highly parallel'' algorithms are implementable by \NC{} circuit families.
A \P-complete problem, that is, a problem for which no highly parallel algorithm exists unless $\P = \NC$, is called ``inherently sequential''.

Now that we have the basic notions of both nondeterministic circuits and PCP characterizations of nondeterministic complexity classes, we can return to our search for a restricted PCP characterization for $\NNC$ circuits.
Following the proof of \autoref{lem:pcpinnp}, we show the following inclusion.
\begin{proposition}\label{prop:pcpinnnc}
  For all non-negative integers $j$ and $t$, all positive integers $k$, and all positive rationals $q$ and $r$,
  \begin{equation*}
    \PCP^{\NC^k}[r \lg \lg n + t, q \lg^j n] \subseteq \NNC^k(\lg^{r + j} n).
  \end{equation*}
\end{proposition}
\begin{proof}
  Let $L \in \PCP^{\NC^k}[r \lg \lg n + t, q \lg^j n]$.
  Let $V$ be the PCP verifier for $L$ which, on input $x$ of length $n$, proof string $\pi$, and random string $\rho$, makes at most $q \lg^j n$ (nonadaptive) queries to the proof string and uses at most $r \lg \lg n + t$ random bits, and which satisfies
  \begin{enumerate}
  \item if $x \in L$, then there exists a $\pi$ of length $2^{r \lg \lg n + t} \cdot q \lg^j n$ such that
    \begin{equation*}
      \Pr_{\rho \in \Sigma^{r \lg \lg n + t}}{\left[V(x, \pi; \rho) \textnormal{ accepts}\right]} = 1,
    \end{equation*}
    and
  \item if $x \notin L$, then for all $\pi$ of length $2^{r \lg \lg n + t} \cdot q \lg^j n$,
    \begin{equation*}
      \Pr_{\rho \in \Sigma^{r \lg \lg n + t}}{\left[V(x, \pi; \rho) \textnormal{ accepts}\right]} < \frac{1}{2}.
    \end{equation*}
  \end{enumerate}
  Our goal is to construct a $\NNC^k(\lg^{r + j} n)$ machine which accepts $x$ if and only if $x \in L$ by simulating the PCP verifier $V$.

  Define the $\NNC^k(\lg^{r + j} n)$ machine $M$ as follows on input $x$ of length $n$:
  \begin{enumerate}
  \item Guess a proof string $\pi$ of length $2^{r \lg \lg n + t} \cdot q \lg^j n$.
  \item For each $\rho$ of length $r \lg \lg n + t$ \emph{in parallel}, simulate $V(x, \pi; \rho)$ and let $b_\rho$ be its output bit (that is, 1 if $V$ accepts and 0 if $V$ rejects).
  \item Let $B$ equal the sum of the output bits for each of the above simulations, and let $B_0 = \frac{1}{2} 2^{r \lg \lg n + t}$.
  \item Accept if and only if $B \geq B_0$.
  \end{enumerate}

  First we show that $M$ can be implemented on a polynomial number of processors with parallel running time $\lg^k n$ and with at most $O(\lg^{j + r} n)$ nondeterministic gates.
  $M$ uses exactly $2^{r \lg \lg n + t}\cdot q \lg^j n$ nondeterministic gates (all in the first step), or more simply, $\lg^r n \cdot 2^t q \lg^j n$, which is in $O(\lg^{j + r} n)$.
  In step 2, $M$ runs $2^{r \lg \lg n + t}$, or more simply $2^t \lg^r n$ (which is bounded above by a polynomial in $n$), instances of $V$ in parallel; the parallel running time of $V$ itself is $O(\lg^k)$, so the parallel running time of this step in $M$ is the same.
  In step 3, $M$ computes the sum of $2^{r \lg \lg n + t}$ numbers, or more simply $2^t \lg^r n$ numbers (each a single bit, so the total size of $B$ is $\lg 2^t \lg^r n$, which equals $r \lg \lg n + t$), and computes the value of $\frac{1}{2} 2^{r \lg \lg n + t}$, or $\frac{1}{2} 2^t \lg^r n$.
  The sum of $2^t \lg^r n$ numbers can be computed by an \NC{} circuit of size $O(\lg^r n)$ and depth $O(r \lg \lg n)$ \cite[Theorem~2.6.1]{savage98}.

  Now we show the correctness of $M$.
  If $x \in L$, then all instances of $V$ accept, so $B = 2^t \lg^r n \geq \frac{1}{2} 2^t \lg^r n = B_0$, and hence $M$ accepts.
  If $x \notin L$, then fewer than half of the instances of $V$ accept, so $B < \frac{1}{2} 2^t \lg^r n = B_0$, and hence $M$ rejects.
  Therefore we have shown that $M$ is a correct algorithm for $L$ which uses a polynomial number of processors, has $O(\lg^k n)$ running time, and uses $O(\lg^{j + r} n)$ nondeterministic gates.
  This concludes the proof.
\end{proof}

Note that there is some slack in this proof.
A polylogarithmic number of simulations of $V$ are being run in parallel, but an \NNC{} circuit could accomodate a polynomial number of simulations.
The number of simulations depends on the length of the random string $\rho$.
Since we will be interested only in the subclasses of $\NNC(\polylog)$, there must also be a polylogarithmic upper bound on the number of nondeterministic gates required, and hence the length of $\rho$ must be in $O(\lg \lg n)$.

\begin{corollary}\label{cor:pcpinnnck}
  For all $k \in \mathbb{N}$ with $k \geq 1$,
  \begin{enumerate}
  \item $\PCP^{\NC^k}[0, O(\lg n)] = \NNC^k(\lg n) = \NC^k$,
  \item $\PCP^{\NC^k}[\lg \lg n + t, O(1)] = \NNC^k(\lg n) = \NC^k$ for all non-negative integers $t$, and
  \item $\PCP^{\NC^k}[O(\lg \lg n), O(\polylog)] \subseteq \NNC^k(\polylog)$.
  \end{enumerate}
\end{corollary}

\begin{corollary}\label{cor:pcpinnnc}
  \mbox{}
  \begin{enumerate}
  \item $\PCP^{\NC}[0, O(\lg n)] = \NNC(\lg n) = \NC$,
  \item $\PCP^{\NC}[\lg \lg n + t, O(1)] = \NNC(\lg n) = \NC$ for all non-negative integers $t$, and
  \item $\PCP^{\NC}[O(\lg \lg n), O(\polylog)] \subseteq \NNC(\polylog)$.
  \end{enumerate}
\end{corollary}

\begin{corollary}
  For all $j \in \mathbb{N}$ with $j \geq 1$, for all $k \in \mathbb{N}$ with $k \geq 1$, and for all positive rationals $q$ and $r$,
  \begin{equation*}
    \PCP^{\NC^k}[r \lg \lg n, q \lg^j n] \subseteq \DSPACE(O(\lg^{\max(k, r + j)} n)).
  \end{equation*}

  Furthermore,
  \begin{equation*}
    \PCP^{\NC}[O(\lg \lg n), O(\polylog)] \subseteq \polyL.
  \end{equation*}
\end{corollary}

\section{Probabilistically checkable proof systems for nondeterministic \texorpdfstring{\NC}{NC} circuits}\label{sec:pcpinnnc}

In the previous section we showed a simulation of a PCP verifier by an \NNC{} circuit.
Our experience with the PCP Theorem and polynomial time verifiers for proabilistically checkable proofs initially led us to conjecture that there is a PCP simulation for \NNC{} circuits.
However, we instead show evidence that such an equality seems unlikely.

\begin{theorem}\label{thm:equiv}
  For all $k \in \mathbb{N}$ with $k \geq 1$ (\textbf{TODO can this be k = 1?}), and for all positive rationals $q$ and $d$, the following are equivalent.
  \begin{enumerate}
  \item $\NNC^k(\lg^d n) = \NC^k$.
  \item $\NNC^k(\lg^d n) = \PCP^{\NC^k}[d \lg \lg n + t, q]$ for some non-negative integer $t$.
  \item There is an integer $c$ with $c > 1$ such that \textsc{$\frac{1}{2}$-gap $c$-CSP} is hard for $\NNC^k(\lg^d n)$ under $\leq_m^{NC^k}$ reductions that produce instances with $O(\lg^d n)$ variables and $O(\lg^d n)$ constraints.
  \end{enumerate}
\end{theorem}

The techniques used to prove this theorem immediately imply the following corollary.

\begin{corollary}
  The following are equivalent.
  \begin{enumerate}
  \item $\NNC(\polylog) = \NC$.
  \item $\NNC(\polylog) = \PCP^{\NC}[O(\lg \lg n), O(1)]$.
  \item \textsc{$\frac{1}{2}$-gap $c$-CSP} is hard for $\NNC(\polylog)$ under $\leq_m^{NC}$ reductions that produce instances with $O(\polylog)$ variables and $O(\polylog)$ constraints, where $c$ is some integer greater than 1.
  \end{enumerate}
\end{corollary}

If the $\NNC(\polylog)$ hierarchy exhibited an upward collapse property, then we could immediately improve \autoref{thm:equiv} to state that $\NNC^k(\polylog) = \NC^k$ if and only if $\NNC^k(\log^d n) = \PCP^{\NC^k}[d \lg \lg n + t, q]$.
Unfortunately, following the discussion at the end of \autoref{sec:nnc}, any proof of such an upward collapse must be non-relativizing, so we cannot currently make that claim.
\textbf{TODO check that this is true.}
Still, we can state the following consequence of this PCP characterization for $\NNC(\polylog)$.
\begin{corollary}
  \mbox{}
  \begin{enumerate}
  \item If $\NNC^k(\log^d) = \PCP^{\NC^k}[d \lg \lg n + t, q]$ for some non-negative integer $t$ and some positive integer $q$, then $\NP \subseteq \DTIME(2^{o(n)})$.
  \item If $\NNC(\polylog) = \PCP^{\NC}[O(\lg \lg n), O(1)]$, then $\NP \subseteq \DTIME(2^{o(n)})$.
  \end{enumerate}
\end{corollary}
\begin{proof}
  Follows immediately from the previous theorem and \autoref{thm:collapse}.
\end{proof}

Now, in order to prove the equivalence, we require the \NC{} analog of \autoref{prop:equivalence}, as well as some derandomization techniques.
Some of the theorems below are \NC{} analogs of results from \cite{fs96}.
We adapt the authors' presentation of derandomization using constant degree spectral expanders.
With this derandomization, we will show a simulation of $O(\lg \lg n)$ bits of randomness by $\lg \lg n + O(1)$ bits of randomness.
The derandomization requires a very explicit constant degree spectral expander.

\begin{definition}
  Suppose $d$ and $n$ are positive integers and $\lambda$ is a real number in the interval $(0, 1)$.
  Suppose $G_n$ is a $d$-regular directed multigraph on $n$ vertices and $M$ is the adjacency matrix of $G_n$.
  We say $G_n$ is a \emph{$\lambda$ spectral expander} if all but the largest eigenvalue of $\frac{1}{d}M$ are in the interval $(0, 1 - \lambda)$.
\end{definition}

The motivation behind the above definition is that the gap between the largest and second largest eigenvalues of the (normalized) adjacency matrix provides information about how quickly a random walk on the graph will approach the uniform distribution on the vertices of the graph.
Since we are concerned about the computational efficiency of such a random walk, it is important that computing the step from one vertex to the next can be performed quickly.

\begin{definition}
  We say a constant degree spectral expander with vertex set $V$ is \emph{very explicit} if each neighbor of a vertex can be computed in $O(\log |V|)$ time.
  (Compare this with the definition of a \emph{fully explicit} expander, in which the neighbor can be computed in time polynomial in $\log |V|$.)
\end{definition}

Infinite families of very explicit constant degree spectral expanders exist; for example, the construction due to Gabber and Galil \cite{gg79} satisfies the definition.

\begin{lemma}[{\cite{aks87}}]\label{lem:expander}
  Let $\mathcal{G}$ be an infinite family of constant degree spectral expanders and let $G_n \in \mathcal{G}$.
  For each subset $C$ of $V(G_n)$ with $|C| \leq \frac{|V(G_n)|}{16}$ there exists a constant $c$ such that for all positive integers $\kappa$, the probability that each $c$th step of a random walk on $G$ of length $\kappa c$ is in $C$ is at most $\frac{1}{2^\kappa}$.
\end{lemma}

\begin{lemma}\label{lem:badsubset}
  Let $L \in \PCPcs{\NC^k}{1}{\frac{1}{16}}{\alpha \lg \lg n}{O(1)}$ for some integer $\alpha$ greater than 1, and let $V$ be the corresponding PCP verifier.
  Let $\ell = 2^{\lg \lg n}$.
  Let $x$ be a binary string of length $n$.
  Let $b(i)$ denote the binary representation of the non-negative integer $i$.
  Let $\mathcal{G}$ be an infinite family of constant degree spectral expanders, and let $G_\ell$ be the graph in $\mathcal{G}$ with $\ell$ nodes.
  There is a subset $C$ of $V(G_\ell)$ such that if the string $x$ is not in $L$ then for all proof strings $\pi$, there is a bijection between
  \begin{enumerate}
  \item the set of all strings $b(i_{1c}) \circ b(i_{2c}) \circ \dotsb \circ b(i_{\alpha c})$ such that $(v_{i_1}, \dotsc, v_{i_{\alpha c}})$ is a walk on $G_\ell$ and $v_{i_{jc}} \in C$ for all $j \in \{1, \dotsc, \alpha\}$ and
  \item the set of all strings $\rho \in \Sigma^{\alpha \lg \lg n}$ such that $V(x, \rho, \pi)$ accepts.
  \end{enumerate}
\end{lemma}
\begin{proof}
  If $x \notin L$, then for all $\pi$, the probability over all strings $\rho$ chosen uniformly at random that $V(x, \rho, \pi)$ accepts is strictly less than $\frac{1}{16}$, so there are less than $\frac{1}{16} 2^{\alpha \lg \lg n}$, such strings $\rho$.
  Call these strings ``bad''.
  Interpret each $\rho$ as $\rho_1 \circ \rho_2 \circ \dotsb \circ \rho_\alpha$, the concatenation of $\alpha$ binary strings, each of length $\lg \lg n$.
  Choose the subset $C$ to be the set of all vertices $v_i$ such that there is some bad string $\rho_1 \circ \dotsb \circ \rho_\alpha$ such that $b(i) = \rho_j$ for some $j \in \{1, \dotsc, \alpha\}$.
  In other words, the set $C$ contains all vertices whose binary representation appears in one of the substrings $\rho_j$ of some bad string.

  \textbf{TODO complete this proof.}
\end{proof}

By using a constant number of independent simulations of a PCP verifier, we can achieve any constant soundness probability.

\begin{lemma}\label{lem:16}
  For all positive integers $k$, we have
  \begin{equation*}
    \PCPcs{\NC^k}{1}{\frac{1}{2}}{O(\lg \lg n)}{O(1)}
    \subseteq
    \PCPcs{\NC^k}{1}{\frac{1}{16}}{O(\lg \lg n)}{O(1)}.
  \end{equation*}
\end{lemma}

\begin{lemma}[{\cite[Lemma~4]{fs96}}]\label{lem:derandomize}
  For all integers $k$ where $k \geq 1$, we have
  \begin{equation*}
    \PCP^{\NC^k}[O(\lg \lg n), O(1)]
    \subseteq
    \PCP^{\NC^k}[\lg \lg n + O(1), O(1)].
  \end{equation*}
\end{lemma}
\begin{proof}
  Let $L \in \PCPcs{\NC^k}{1}{\frac{1}{2}}{O(\lg \lg n)}{O(1)}$.
  $L$ is also in $\PCPcs{\NC^k}{1}{\frac{1}{16}}{O(\lg \lg n)}{O(1)}$ by \autoref{lem:16}.
  This means there exists a $(\alpha \lg \lg n, q, 1, \frac{1}{16})$-PCP verifier $V$ for $L$, for some positive rational $\alpha$ and positive integer $q$.
  We assume without loss of generality that $\alpha > 1$; if $\alpha \leq 1$ the statement is immediately true.
  Our goal is to construct a $(\lg \lg n + t, O(1), 1, \frac{1}{2})$-PCP verifier $V'$ for $L$, for some constant integer $t$.
  Suppose for now that $t$ has been fixed; we will define it later in the proof.
  We construct the verifier $V'$ as follows on input $x$ of length $n$, random string $\rho$ of length $\lg \lg n + t$ and proof string $\pi$ of length $2^{\lg \lg n + t} q$ (this is the maximum number of possible bits of the proof string queried by a nonadaptive verifier with $\lg \lg n$ bits of randomness).
  Interpret $\rho$ as $\rho_1 \circ \rho_2$, where $|\rho_1| = \lg \lg n$ and $|\rho_2| = t$.

  Intuitively, the verifier will simulate $\alpha \lg \lg n$ random bits with only $\lg \lg n + t$ random bits by using a random walk on an expander graph.
  Let $\ell = 2^{\lg \lg n}$ and let $G_\ell$ be a $d$-regular very explicit spectral expander on $\ell$ vertices, for some positive integer $d$.
  Let $C$ be the subset of vertices guaranteed by \autoref{lem:badsubset}.
  Observe that the cardinality of $C$ is less than $\frac{|V(G_\ell)|}{16}$.
  By \autoref{lem:expander} there is a constant $c$ such that the probability that a random walk of length $\alpha c$ on $G_\ell$ arrives at a vertex in $C$ on every $c$th step is at most $\frac{1}{2^\alpha}$.
  We will be using such a random walk to simulate the randomness of $V$ and we want the soundness probability of $V'$ to be strictly less than $\frac{1}{2}$, so we will require the length of the walk to be strictly greater than $c$.

  Now we are ready to describe $V'$.
  \begin{enumerate}
  \item
    Perform a random walk of length $\alpha c$ on $G_\ell$ from an initial vertex chosen uniformly at random.
    Let $(v_{i_1}, \dotsc, v_{i_{\alpha c}})$ be the sequence of vertices that comprise this walk.
  \item
    Let $s = b(i_{1c}) \circ b(i_{2c}) \circ \dotsb \circ b(i_{\alpha c})$.
    Observe that $|s| = \alpha |b(i_k)| = \alpha \lg |V(G_\ell)| = \alpha \lg 2^{\lg \lg n} = \alpha \lg \lg n$.
  \item Accept if and only if $V(x, s, \pi)$ accepts.
  \end{enumerate}
  $V'$ requires $\lg \lg n$ random bits to choose an initial vertex for the walk and $\lg d$ random bits at each of the $\alpha c$ steps of the walk.
  Thus $V'$ uses $\lg \lg n + \alpha c \lg d$ random bits in total; now we define $t$ to be $\alpha c \lg d$, a constant independent of $n$.
  Since $V'$ only accesses the proof string $\pi$ via the simulation of $V$, the verifier $V'$ queries exactly the same number of bits of the proof string as does the verifier $V$.

  Performing a single step in a very explicit expander takes $O(|V(G_\ell)|)$ time.
  Thus, performing a random walk of length $\alpha c$ takes $O(\alpha c |V(G_\ell)|)$ time.
  Since $G_\ell$ has exactly $2^{\lg \lg n}$, or more simply $\lg n$, vertices, the total computation time for the random walk is $O(\alpha c \lg n)$, which is in $O(\lg n)$.
  Since $V$ is an $\NC^k$ algorithm, the simulation of $V$ can be performed by a polynomial size, $O(\log^k n)$ depth circuit.
  Therefore the overall time required by $V'$ is $O(\lg n) + O(\log^k n)$, which is in $O(\log^k n)$ for all $k \geq 1$.

  Now we show that $V'$ achieves the necessary completeness and soundness error bounds.
  Let $x$ be a string of length $n$, and $\pi$ be any sufficiently long proof string.
  By construction, we have
  \begin{equation*}
    \Pr_\rho[V'(x, \rho, \pi) \text{ accepts}] = \Pr_\rho[V(x, s, \pi) \text{ accepts}],
  \end{equation*}
  where $\rho$ is a binary string of length $\lg \lg n + t$ chosen uniformly at random, and $s$ is generated by the random walk on $G_\ell$ as described above.
  If $x \in L$, then there exists a proof string $\pi$ such that for all strings $\gamma$, we have $V(x, \gamma, \pi)$ accepts, and in particular, $V(x, s, \pi)$ accepts.
  Therefore, for all strings $\rho$, it follows that $V'(x, \rho, \pi)$ accepts.
  If $x \notin L$, then \autoref{lem:badsubset} applies, and we have
  \begin{align*}
    \Pr_\rho[V'(x, \rho, \pi) \text{ accepts}] & = \Pr_\rho[V(x, s, \pi) \text{ accepts}] \\
    & = \Pr_\rho[\forall j \in \{1, \dotsc, \alpha\} \colon v_{i_{jc}} \in C],
  \end{align*}
  where each $v_{i_{jc}}$ is a vertex on the random walk $(v_{i_1}, \dotsc, v_{i_{\alpha c}})$ from which $s$ is derived.
  This probability is at most $\frac{1}{2^\alpha}$ by \autoref{lem:expander}, which is strictly less than $\frac{1}{2}$ because $\alpha > 1$.

  To summarize, we have shown that $V'$ uses exactly $\lg \lg n + \alpha c \lg d$ bits of randomness, makes $O(1)$ queries to the proof string, can be implemented by an $\NC^k$ circuit, and has completeness 1 and soundness $\frac{1}{2}$.
  Therefore, $L \in \PCP^{\NC^k}[\lg \lg n + O(1), O(1)]$.
\end{proof}

Using the derandomizations from \autoref{prop:pcpinnnc} and \autoref{lem:derandomize}, we can prove \autoref{thm:equiv}.
We divide the proof of the theorem into several lemmata.
The first lemma shows the equivalence of the first and second statements, the second lemma provides an \NC{} analog of \autoref{lem:constraintsp}, and the third shows the equivalence of the second and third statements.

\begin{lemma}\label{lem:1}
  For all positive integers $k$ and all non-negative rationals $d$, we have $\NNC^k(\lg^d n) = \NC^k$ if and only if there is a non-negative integer $t$ such that $\NNC^k(\lg^d n) = \PCP^{\NC^k}[d \lg \lg n + t, q]$.
\end{lemma}
\begin{proof}
  First, suppose $\NNC^k(\lg^d n) = \NC^k$.
  Then we have
  \begin{equation*}
    \NNC^k(\lg^d n)
    = \NC^k
    = \PCP^{\NC^k}[0, 0]
    \subseteq \PCP^{\NC^k}[d \lg \lg n, q].
  \end{equation*}
  Combine this with \autoref{prop:pcpinnnc} to achieve equality.
  In this case, we choose $t = 0$.

  For the converse, suppose $L$ is a language in $\NNC^k(\lg^d n)$.
  By hypothesis, $L \in \PCP^{\NC^k}[d \lg \lg n + t, q]$ for some non-negative integer $t$.
  Since $d \lg \lg n + t$ is in $O(\lg \lg n)$, we also have that $L \in \PCP^{\NC^k}[d' \lg \lg n, q]$ for some $d'$ greater than or equal to $d$.
  By \autoref{lem:derandomize}, there exists a $t'$ such that $L \in \PCP^{\NC^k}[\lg \lg n + t', q]$.
  Apply \autoref{cor:pcpinnnck} to conclude that $L \in \NC^k$.
\end{proof}

\begin{lemma}\label{lem:constraintsnc}
  Suppose $d$ and $t$ are non-negative integers.
  Let $L$ be a language in $\PCP^{\NC^k}[d \lg \lg n + t, O(1)]$.
  Then there is a $\leq_m^{NC^k}$ reduction from $L$ to \textsc{$\frac{1}{2}$-gap $q$-CSP}, for some integer $q$ greater than 1.
  Furthermore, the reduction yields $O(\lg^d n)$ variables and $O(\lg^d n)$ constraints on inputs of length $n$.
\end{lemma}
\begin{proof}
  The proof is similar to the proof of \autoref{lem:constraintsp}; the only difference is in the length of the random string $\rho$, and hence the size of the output of the reduction.
  Since the verifier $V$ now uses only $d \lg \lg n + t$ bits of randomness, the reduction enumerates (in parallel) each of the $2^{d \lg \lg n + t}$ possible random strings of length $d \lg \lg n + t$, instead of the $2^{r \lg n}$ possible strings of length $r \lg n$.
  Observe that the number of variables must be $q 2^{d \lg \lg n + t}$, which equals $q 2^t \lg^d n$, and the number of constraints is $2^t \lg^d n$, both members of $O(\lg^d n)$.
\end{proof}

\begin{lemma}\label{lem:2}
  For all positive integers $k$ and all non-negative rationals $d$, $\NNC^k(\lg^d n) = \PCP^{\NC^k}[d \lg \lg n + t, q]$ for some non-negative integer $t$ if and only if there exists an integer $c$ with $c > 1$ such that \textsc{$\frac{1}{2}$-gap $c$-CSP} is hard for $\NNC^k(\lg^d n)$ under $\leq_m^{NC^k}$ reductions that produce instances with $O(\lg^d n)$ variables and $O(\lg^d n)$ constraints.
\end{lemma}
\begin{proof}
  One direction of the equivalence follows immediately \autoref{lem:constraintsnc}.
  Thus it suffices to prove the converse implication.
  The proof is nearly the same as the proof of \autoref{prop:equivalence}; the only difference is in the length of the random string $\rho$, and hence the size of the output of the reduction.
  Observe that the PCP verifier in the proof that the latter statement implies the former requires $d \lg \lg n + \lg c$ bits of randomness to select one of the $c \lg^d n$ constraints uniformly at random, where $c$ is a constant, so we choose $t = \lg c$.
  To prove the other direction of the inclusion and complete the proof, we apply \autoref{prop:pcpinnnc}.
\end{proof}

\autoref{thm:equiv} follows immediately from \autoref{lem:1} and \autoref{lem:2}.

\section{About this work}

Copyright 2013 Jef{}frey Finkelstein.

This work is licensed under the Creative Commons Attribution-ShareAlike License 3.0.
Visit \mbox{\url{https://creativecommons.org/licenses/by-sa/3.0/}} to view a copy of this license.

The \LaTeX{} markup which generated this document is available on the World Wide Web at \mbox{\url{https://github.com/jfinkels/ncpcp}}.
It is also licensed under the Creative Commons Attribution-ShareAlike License.

The author can be contacted via email at \email{jeffreyf@bu.edu}.

\bibliographystyle{plain}
\bibliography{references}

\end{document}
