\documentclass[draft]{article}

% Package `amsthm` and `thmtools` must come before package `hyperref`.
\usepackage{amsthm}
\usepackage{thmtools}
% Package `hyperref` must come before package `complexity`.
\usepackage[pdftitle={Restricted probabilistically checkable proofs}, pdfauthor={Jeffrey Finkelstein}]{hyperref}
\usepackage{complexity}
\usepackage{amsmath}
\usepackage{amssymb}

\declaretheorem[numberwithin=section]{theorem}
\declaretheorem[numberlike=theorem]{lemma}
\declaretheorem[numberlike=theorem]{proposition}
\declaretheorem[numberlike=theorem, style=definition]{definition}

%% Arguments:
%%  1. Complexity class of the verifier
%%  2. Completeness probability
%%  3. Soundness probability
%%  4. Randomness
%%  5. Number of queries
\newcommand{\PCPcs}[5]{\PCP^{#1}_{#2, #3}\left[#4, #5\right]}
\newcommand{\lglg}{\lg\lg}

\newenvironment{proofidea}{\begin{proof}[Proof~idea]}{\end{proof}}

\title{Restricted probabilistically checkable proofs}
\author{Jef{}frey~Finkelstein}
\date{\today}

\begin{document}
\maketitle

\section{Preliminaries}

\begin{definition}
  For all functions $f, g \colon \mathbb{N} \to \mathbb{R}$, the function $f$ is in the class $O(g(n))$ if there exist real numbers $c$ and $N$ such that for all natural numbers $n$ we have $n > N$ implies $f(n) \leq c \cdot g(n)$.
  If $f(n) < c \cdot g(n)$ then $f(n)$ is in $o(g(n))$.
\end{definition}

\begin{definition}[{{\cite[Definition~1.1]{dinur07}}}]
  Let $V$ be a finite set of variables, defined by $V = \{x_1, x_2, \dotsc, x_n\}$, let $\Gamma$ be a finite alphabet, and let $q$ be a natural number.
  A \emph{$q$-ary constraint} is a $q + 1$ tuple, $(C, i_1, i_2, \dotsc, i_q)$, where $C \subseteq \Gamma^q$ and $i_k \in \{1, 2, \dotsc, n\}$ for all $k \in \{1, 2, \ldots, q\}$.
  Here, $C$ is considered the set of ``acceptable'' values for the variables.

  An \emph{assignment} is a function $a \colon V \to \Gamma$.
  An assignment \emph{satisfies} a constraint if $(a(v_{i_1}), a(v_{i_2}), dotsc, a(v_{i_q})) \in C$.
\end{definition}

\begin{definition}
  Suppose $D$ is a collection of constraints over the set of variables $V$.
  Let $A$ represent the set of all assignments to $V$.
  The \emph{satisfiability fraction} of a collection of constraints, denoted $\SAT(D)$, is defined by
  \begin{equation*}
    SAT(D) = \max_{a \in A}{\frac{\left|\left\{ C_i \in D \, \middle| \, a \text{ satisfies } C_i \right\}\right|}{\left|D\right|}}.
  \end{equation*}
\end{definition}

\begin{definition}[\textsc{Constraint Satisfaction Problem} (or \textsc{CSP})]
  \mbox{}

  \textbf{Instance:} finite alphabet $\Gamma$ with $|\Gamma| > 1$, finite set of variables $V$, finite set of constraints $D$.

  \textbf{Question:} Are all constraints in $D$ satisfiable?
\end{definition}

In the following definitions, let $q$ be a fixed natural number greater than 1.

\begin{definition}[\textsc{$q$-CSP}]
  \mbox{}

  \textbf{Instance:} finite alphabet $\Gamma$ with $|\Gamma| > 1$, finite set of variables $V$, finite set of $q$-ary constraints $D$.

  \textbf{Question:} Are all constraints $D$ satisfiable?
\end{definition}

\begin{definition}[\textsc{$\epsilon$-gap $q$-CSP}]
  \mbox{}

  \textbf{Instance:} finite alphabet $\Gamma$ with $|\Gamma| > 1$, finite set of variables $V$, finite set of $q$-ary constraints $D$ with the restriction that either $SAT(D) < \frac{1}{2}$ or $SAT(D) = 1$.

  \textbf{Question:} Are all constraints in $D$ satisfiable?
\end{definition}

\begin{definition}
  A \emph{\PCP{} verifier} is a probabilistic Turing machine which has sequential access to an input string $x$, sequential access to a random string $\rho$, and \emph{nonadaptive} random access (that is, arbitrary access) to a proof string $\pi$.
\end{definition}

\begin{definition}
  A language $L$ has a $(a \cdot r(n), b \cdot q(n))$-\emph{$\PCP_{c(n), s(n)}$ verifier} if there exists a \PCP{} verifier $V$ such that $V$ uses at most $a \cdot r(n)$ bits of the random string $\rho$, $V$ makes at most $b \cdot q(n)$ \emph{nonadaptive} queries to bits of the proof $\pi$, and the following conditions hold
  \begin{enumerate}
  \item if $x \in L$, then 
    \begin{equation*}
      \exists \pi \in \Sigma^{a \cdot r(n) + \lg{b \cdot q(n)}} \colon \Pr_{\rho \in \Sigma^{a \cdot r(n)}}{\left[V(x, \pi; \rho) \textnormal{ accepts}\right]} >= c(n),
    \end{equation*}
    and
  \item if $x \notin L$, then
    \begin{equation*}
      \forall \pi \in \Sigma^{a \cdot r(n) + \lg{b \cdot q(n)}} \colon \Pr_{\rho \in \Sigma^{a \cdot r(n)}}{\left[V(x, \pi; \rho) \textnormal{ accepts}\right]} < s(n),
    \end{equation*}
  \end{enumerate}
  for some natural numbers $a$ and $b$.
\end{definition}

A verifier which uses $q$ adaptive random access queries to the proof string can be simulated by a verifier which uses $2^q$ nonadaptive random access queries to the proof string.
The total number of queried bits of the proof string for an \emph{adaptive} $(a \cdot r(n), b \cdot q(n))$-\PCP{} verifier is $a \cdot r(n) + b \cdot q(n)$ and for a \emph{nonadaptive} \PCP{} verifier, $a \cdot r(n) + \lg{b \cdot q(n)}$.
In this work, we will consider only nonadaptive \PCP{} verifiers; for nonadaptive \PCP{} verifiers there are $2^{a \cdot r(n) + \lg{b \cdot q(n)}}$ possible proof strings, or more simply $2^{a \cdot r(n)} \cdot b \cdot q(n)$.

\begin{definition}
  Let $\PCPcs{\mathcal{C}}{c(n)}{s(n)}{a \cdot r(n)}{b \cdot q(n)}$ be the class of all languages $L$ such that $L$ has a $(a \cdot r(n), b \cdot q(n))$-$\PCP_{c(n), s(n)}$ verifier $V$ computable by a $\mathcal{C}$ algorithm.

  More generally, if $\mathcal{F}$ and $\mathcal{G}$ are classes of functions,
  \begin{equation*}
    \PCPcs{\mathcal{C}}{c(n)}{s{n}}{\mathcal{F}}{\mathcal{G}} = \bigcup_{f \in \mathcal{C}, g \in \mathcal{G}}{\PCPcs{\mathcal{C}}{c(n)}{s(n)}{f(n)}{g(n)}},
    \end{equation*}
\end{definition}

From the definition, we see immediately that
\begin{equation*}
  \PCPcs{\mathcal{C}}{c(n)}{s{n}}{O(r(n))}{O(q(n))} = \bigcup_{a \in \mathbb{N}, b \in \mathbb{N}}{\PCPcs{\mathcal{C}}{c(n)}{s(n)}{a \cdot r(n)}{b \cdot q(n)}}.
\end{equation*}
The class in which we are interested is $\PCPcs{\NC}{1}{\frac{1}{2}}{a \lglg{n}}{b \lg n}$; we abbreviate this class $\PCP[a \lglg n, b \lg n]$.

\section{The PCP Theorem}

The celebrated ``PCP Theorem'' can be stated as follows.
\begin{theorem}
  $\NP = \PCPcs{\P}{1}{\frac{1}{2}}{O(\lg n)}{O(1)}$.
\end{theorem}
The proof has two parts, one easy and one hard.
The following lemma proves the easy part.
\begin{lemma}\label{lem:pcpinnp}
  $\PCPcs{\P}{1}{\frac{1}{2}}{O(\lg n)}{O(1)} \subseteq \NP$.
\end{lemma}
\begin{proof}
  Let $L \in \PCPcs{\P}{1}{\frac{1}{2}}{O(\lg n)}{O(1)}$, so there exists a polynomial time \PCP{} verifier $V$ subject to the appropriate restrictions.
  Construct a nondeterministic Turing machine $N$ as follows.

  On input $x$, nondeterministically guess a proof string $\pi$ of length $r \lg n + \lg q$, where $q$ and $r$ are the appropriate constants for the language $L$.
  Enumerate each ``random'' string $\rho$ of length $r \lg  n$, and for each $\rho$, simulate $V$ on input $x$, proof string $\pi$, and random string $\rho$.
  If $V$ accepts in at least half of the simulations, then accept; otherwise reject.

  This machine uses a polynomial amount of nondeterminism, runs in polynomial time (due to the fact that $V$ runs in polynomial time, and counting the number of accepting simulations can also be performed efficiently) and accepts exactly when at least half of the instances of $V(x, \pi; \rho)$ accept.
  Therefore $x \in L$ if and only $N$ accepts $x$, and we have $L \in \NP$.  
\end{proof}

The hard part uses the following ``inapproximability'' view of the PCP Theorem.
\begin{proposition}[{{\cite[Theorem~1.3]{dinur07}}}]
  The following are equivalent.
  \begin{enumerate}
  \item $\NP = \PCPcs{\P}{1}{\frac{1}{2}}{O(\lg n)}{O(1)}$.
  \item There exists an integer $q$, with $q > 1$, such that \textsc{$\frac{1}{2}$-gap $q$-CSP} is \NP-hard.
  \end{enumerate}
\end{proposition}
\begin{proofidea}
  \mbox{}
  \begin{enumerate}
  \item ($1 \implies 2$) Construct a set of constraints using the Cook-Levin reduction where each constraint is satisfied exactly when the \PCP{} verifier accepts.
  \item ($2 \implies 1$) It suffices to show $\NP \subseteq \PCPcs{\P}{1}{\frac{1}{2}}{O(\lg n)}{O(1)}$, since we know the opposite inclusion by \autoref{lem:pcpinnp}.
    The \PCP{} verifier computes the reduction from an arbitrary \NP{} language to \textsc{$\frac{1}{2}$-gap $q$-CSP}, uses its randomness to select a constraint uniformly at random, then queries the proof string in the corresponding locations, accepting if and only if the proof string reflects a satisfying assignment.
  \end{enumerate}
\end{proofidea}

\bibliographystyle{plain}
\bibliography{references}

\end{document}
