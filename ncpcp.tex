\documentclass[]{article}

% Package `amsthm` and `thmtools` must come before package `hyperref`.
\usepackage{amsthm}
\usepackage{thmtools}
% Package `hyperref` must come before package `complexity`.
\usepackage[pdftitle={Restricted probabilistically checkable proofs}, pdfauthor={Jeffrey Finkelstein}]{hyperref}
\usepackage{complexity}
\usepackage{amsmath}
\usepackage{amssymb}

\declaretheorem[numberwithin=section]{theorem}
\declaretheorem[numberlike=theorem]{corollary}
\declaretheorem[numberlike=theorem]{lemma}
\declaretheorem[numberlike=theorem]{proposition}
\declaretheorem[numberlike=theorem, style=definition]{construction}
\declaretheorem[numberlike=theorem, style=definition]{definition}

%% Arguments:
%%  1. Complexity class of the verifier
%%  2. Completeness probability
%%  3. Soundness probability
%%  4. Randomness
%%  5. Number of queries
\newcommand{\PCPcs}[5]{\PCP^{#1}_{#2, #3}\left[#4, #5\right]}
\newcommand{\lglg}{\lg\lg}

\newenvironment{proofidea}{\begin{proof}[Proof~idea]}{\end{proof}}

\title{Restricted probabilistically checkable proofs}
\author{Jef{}frey~Finkelstein}
\date{\today}

\begin{document}
\maketitle

\section{Preliminaries}

\begin{definition}
  For all functions $f, g \colon \mathbb{N} \to \mathbb{R}$, the function $f$ is in the class $O(g(n))$ if there exist real numbers $c$ and $N$ such that for all natural numbers $n$ we have $n > N$ implies $f(n) \leq c \cdot g(n)$.
  If $f(n) < c \cdot g(n)$ then $f(n)$ is in $o(g(n))$.
\end{definition}

\begin{definition}[{{\cite[Definition~1.1]{dinur07}}}]
  Let $V$ be a finite set of variables, defined by $V = \{x_1, x_2, \dotsc, x_n\}$, let $\Gamma$ be a finite alphabet, and let $q$ be a natural number.
  A \emph{$q$-ary constraint} is a $q + 1$ tuple, $(C, i_1, i_2, \dotsc, i_q)$, where $C \subseteq \Gamma^q$ and $i_k \in \{1, 2, \dotsc, n\}$ for all $k \in \{1, 2, \ldots, q\}$.
  Here, $C$ is considered the set of ``acceptable'' values for the variables.

  An \emph{assignment} is a function $a \colon V \to \Gamma$.
  An assignment \emph{satisfies} a constraint if $(a(v_{i_1}), a(v_{i_2}), \dotsc, a(v_{i_q})) \in C$.
\end{definition}

\begin{definition}
  Suppose $D$ is a collection of constraints over the set of variables $V$.
  Let $A$ represent the set of all assignments to $V$.
  The \emph{satisfiability fraction} of a collection of constraints, denoted $SAT(D)$, is defined by
  \begin{equation*}
    SAT(D) = \max_{a \in A}{\frac{\left|\left\{ C_i \in D \, \middle| \, a \text{ satisfies } C_i \right\}\right|}{\left|D\right|}}.
  \end{equation*}
\end{definition}

\begin{definition}[\textsc{Constraint Satisfaction Problem} (or \textsc{CSP})]
  \mbox{}

  \textbf{Instance:} finite alphabet $\Gamma$ with $|\Gamma| > 1$, finite set of variables $V$, finite set of constraints $D$.

  \textbf{Question:} Are all constraints in $D$ satisfiable?
\end{definition}

In the following definitions, let $q$ be a fixed natural number greater than 1.

\begin{definition}[\textsc{$q$-CSP}]
  \mbox{}

  \textbf{Instance:} finite alphabet $\Gamma$ with $|\Gamma| > 1$, finite set of variables $V$, finite set of $q$-ary constraints $D$.

  \textbf{Question:} Are all constraints $D$ satisfiable?
\end{definition}

\begin{definition}[\textsc{Maximum $q$-CSP}]
  \mbox{}

  \textbf{Instance:} finite alphabet $\Gamma$ with $|\Gamma| > 1$, finite set of variables $V$, finite set of $q$-ary constraints $D$.

  \textbf{Solution:} An assignment $\alpha \colon V \to \Gamma$.

  \textbf{Measure:} The number of constraints in $D$ satisfied by $\alpha$.
\end{definition}

\begin{definition}[\textsc{$\epsilon$-gap $q$-CSP}]
  \mbox{}

  \textbf{Instance:} finite alphabet $\Gamma$ with $|\Gamma| > 1$, finite set of variables $V$, finite set of $q$-ary constraints $D$ with the restriction that either $SAT(D) < \frac{1}{2}$ or $SAT(D) = 1$.

  \textbf{Question:} Are all constraints in $D$ satisfiable?
\end{definition}

\begin{definition}
  A \emph{\PCP{} verifier} is a probabilistic Turing machine which has sequential access to an input string $x$, sequential access to a random string $\rho$, and \emph{nonadaptive random access} to a proof string $\pi$.
\end{definition}

\begin{definition}
  For all natural numbers $a$ and $b$, a language $L$ has a $(a \cdot r(n), b \cdot q(n))$-\emph{$\PCP_{c(n), s(n)}$ verifier} if there exists a \PCP{} verifier $V$ such that $V$ uses at most $a \cdot r(n)$ bits of the random string $\rho$, $V$ makes at most $b \cdot q(n)$ \emph{nonadaptive} queries to bits of the proof $\pi$, and the following conditions hold
  \begin{enumerate}
  \item if $x \in L$, then
    \begin{equation*}
      \exists \pi \in \Sigma^* \colon \Pr_{\rho \in \Sigma^{a \cdot r(n)}}{\left[V(x, \pi; \rho) \textnormal{ accepts}\right]} \geq c(n),
    \end{equation*}
    and
  \item if $x \notin L$, then
    \begin{equation*}
      \forall \pi \in \Sigma^* \colon \Pr_{\rho \in \Sigma^{a \cdot r(n)}}{\left[V(x, \pi; \rho) \textnormal{ accepts}\right]} < s(n).
    \end{equation*}
  \end{enumerate}
\end{definition}

In this work, we will consider only nonadaptive \PCP{} verifiers.
Since a (nonadaptive) $(a \cdot r(n), b \cdot q(n))$-\PCP{} verifier can read at most $2^{a \cdot r(n)} \cdot b \cdot q(n)$ locations of the proof string with nonzero probability, we assume without loss of generality that the proof provided to the verifier is of length at most $2^{a \cdot r(n)} \cdot b \cdot q(n)$ \cite[Remark~11.6]{ab09}.
(Note that a verifier which uses $q$ adaptive random access queries to the proof string can be simulated by a verifier which uses $2^q$ nonadaptive random access queries to the proof string, so in the adaptive case, the proof string could be of length $2^{a \cdot r(n) + b \cdot q(n)}$.)

\begin{definition}
  Let $\PCPcs{\mathcal{C}}{c(n)}{s(n)}{a \cdot r(n)}{b \cdot q(n)}$ be the class of all languages $L$ such that $L$ has a $(a \cdot r(n), b \cdot q(n))$-$\PCP_{c(n), s(n)}$ verifier $V$ computable by a $\mathcal{C}$ algorithm.

  More generally, if $\mathcal{F}$ and $\mathcal{G}$ are classes of functions,
  \begin{equation*}
    \PCPcs{\mathcal{C}}{c(n)}{s{n}}{\mathcal{F}}{\mathcal{G}} = \bigcup_{f \in \mathcal{C}, g \in \mathcal{G}}{\PCPcs{\mathcal{C}}{c(n)}{s(n)}{f(n)}{g(n)}},
    \end{equation*}
\end{definition}

From the definition, we see immediately that
\begin{equation*}
  \PCPcs{\mathcal{C}}{c(n)}{s{n}}{O(r(n))}{O(q(n))} = \bigcup_{a \in \mathbb{N}, b \in \mathbb{N}}{\PCPcs{\mathcal{C}}{c(n)}{s(n)}{a \cdot r(n)}{b \cdot q(n)}}.
\end{equation*}

\section{Probabilistically checkable proofs for \texorpdfstring{\NP}{NP}}

The celebrated ``PCP Theorem'' can be stated as follows.
\begin{theorem}
  $\NP = \PCPcs{\P}{1}{\frac{1}{2}}{O(\lg n)}{O(1)}$.
\end{theorem}
The proof has two parts, one easy and one hard.
The following lemma proves the easy part.
\begin{lemma}\label{lem:pcpinnp}
  $\PCPcs{\P}{1}{\frac{1}{2}}{O(\lg n)}{O(1)} \subseteq \NP$.
\end{lemma}
\begin{proof}
  Let $L \in \PCPcs{\P}{1}{\frac{1}{2}}{O(\lg n)}{O(1)}$, so there exists a polynomial time \PCP{} verifier $V$ subject to the appropriate restrictions.
  Construct a nondeterministic Turing machine $N$ as follows.

  On input $x$, nondeterministically guess a proof string $\pi$ of length $2^{r \lg n + \lg q}$, where $q$ and $r$ are the appropriate constants for the language $L$.
  Enumerate each ``random'' string $\rho$ of length $r \lg  n$, and for each $\rho$, simulate $V$ on input $x$, proof string $\pi$, and random string $\rho$.
  If $V$ accepts in at least half of the simulations, then accept; otherwise reject.

  This machine uses a polynomial amount of nondeterminism, runs in polynomial time (due to the fact that $V$ runs in polynomial time, and counting the number of accepting simulations can also be performed efficiently) and accepts exactly when at least half of the instances of $V(x, \pi; \rho)$ accept.
  Therefore $x \in L$ if and only $N$ accepts $x$, and we have $L \in \NP$.  
\end{proof}

The hard part uses the following ``inapproximability'' view of the PCP Theorem.
\begin{proposition}[{{\cite[Theorem~1.3]{dinur07}}}]\label{prop:equivalence}
  The following are equivalent.
  \begin{enumerate}
  \item $\NP \subseteq \PCPcs{\P}{1}{\frac{1}{2}}{O(\lg n)}{O(1)}$.
  \item There exists an integer $q$, with $q > 1$, such that \textsc{$\frac{1}{2}$-gap $q$-CSP} is \NP-hard.
  \end{enumerate}
\end{proposition}

Before proving this proposition, we provide one part of it as a separate lemma, because it will be of use in later theorems.

\begin{lemma}\label{lem:constraintsp}
  If $L \in \PCPcs{\P}{1}{\frac{1}{2}}{O(\lg n)}{O(1)}$ then there is a $\leq_m^P$ reduction from $L$ to \textsc{$\frac{1}{2}$-gap $q$-CSP}, for some integer $q$ greater than 1.
\end{lemma}
\begin{proof}
  Let $L$ be a language in $\PCPcs{\P}{1}{\frac{1}{2}}{O(\lg n)}{O(1)}$.
  Let $V$ be the polynomial time \PCP{} verifier for $L$ which uses $r \lg n$ bits of randomness and queries $q$ bits of the proof string, for some constants $r$ and $q$.
  Consider the Cook-Levin transformation of the operation of $V$ into a Boolean circuit; the circuit will have input variables representing the bits of the input $x$, the bits of the random string $\rho$, and the bits of the proof string $\pi$.
  For each fixed input $x$ of length $n$ and each fixed $\rho \in \Sigma^{r \lg n}$, simplify the circuit based on the values (that is, the 0s and 1s) of the variables corresponding to $x$ and the variables corresponding to $\rho$ into a Boolean function (also called a Boolean constraint) which depends only on the bits of the proof string $\pi$.
  Let $\phi_{x, \rho}$ be that Boolean constraint; note that it depends only on $q$ Boolean variables.
  Let $U_{x, \rho}$ be the variables corresponding to the bits of the proof string $\pi$ queried by $V$ on input $x$ and random string $\rho$.

  Now we construct a reduction from $L$ to \textsc{$\frac{1}{2}$-gap $q$-CSP}.
  Define the reduction $f$ by $f(x) = (\Gamma, U, D)$, where
  \begin{align*}
    \Gamma & = \{0, 1\}, \\
    U & = \bigcup_{\rho \in \Sigma^{r \lg n}}{U_{x, \rho}}, \text{ and} \\
    D & = \left\{\phi_{x, \rho}\right\}_{\rho \in \Sigma^{r \lg n}}.
  \end{align*}
  $f(x)$ is polynomial time computable (there are $qn^r$ variables in $U$ and $n^r$ constraints in $D$, both polynomials in $n$).
  By the correctness of the Cook-Levin reduction and by the completeness and soundness of the \PCP{} verifier if $x \in L$ then there exists a $\pi$ such that for all strings $\rho$, we have $V(x, \rho; \pi)$ accepts and hence all the constraints are satisfiable.
  Furthermore, if $x \notin L$ then for all $\pi$, on less than half of the strings $\rho$ will $V(x, \pi; \rho)$ accept, so less than half of the constraints will be satisfiable.
  Therefore we have shown a correct polynomial time reduction from $L$ to \textsc{$\frac{1}{2}$-gap $q$-CSP}.
\end{proof}

\begin{proof}[Proof of \autoref{prop:equivalence}]
  One direction of the equivalence follows immediately from the inclusion in the hypothesis and from \autoref{lem:constraintsp}.
  Thus it suffices to prove the converse implication.
  Suppose \textsc{$\frac{1}{2}$-gap $q$-CSP} is \NP-hard for some $q$ greater than 1.
  Let $L$ be a language in \NP.
  By hypothesis there exists a (deterministic) polynomial time computable reduction from $L$ to \textsc{$\frac{1}{2}$-gap $q$-CSP}.
  Construct the \PCP{} verifier as follows.
  \begin{enumerate}
  \item Compute the reduction to produce a set of constraints.
  \item Use $O(\lg n)$ random bits to choose a constraint uniformly at random.
  \item Check that the constraint is satisfied by querying the proof string at the appropriate locations (the locations corresponding to the $q$ variables in the constraint).
  \end{enumerate}

  If $x \in L$ then all constraints are satisfiable, so there exists an assignment such that the verifier will accept on all random choices of the constraint.
  If $x \notin L$ then fewer than half of the constraints are satisfiable, so for any assignment the probability that the verifier will select a satisfied constraint is less than half.
  Therefore we have shown a correct \PCP{} verifier with the appropriate parameters for an arbitrary language in \NP.
\end{proof}
With this equivalence, we can reduce the problem of showing that $\NP \subseteq \PCPcs{\P}{1}{\frac{1}{2}}{O(\lg n)}{O(1)}$ to the problem of showing that \textsc{$\frac{1}{2}$-gap $q$-CSP} is \NP-hard.
An almost entirely combinatoric approach can solve the latter problem \cite{dinur07}.

\section{PCPs in NNC}

One of our goals is to characterize smaller complexity classes using more restrictive \PCP{} classes.
We hope to use such a characterization for applications to inapproximability in the realm of optimization problems whose corresponding decision problems are \P-complete, but which admit a ``good'' highly parallel approximation.
In this work, ``highly parallel'' algorithms are implementable by \NC{} circuit families.
A \P-complete problem, that is, a problem for which no highly parallel algorithm exists unless $\P = \NC$, is called ``inherently sequential''.

In order to utilize the proof techniques from the \NP{} version of the \PCP{} Theorem, we consider a nondeterministic generalization of \NC.
\begin{definition}
  A \emph{nondeterministic gate} (or \emph{guess gate}) in a Boolean circuit is a gate with no inputs and one output.
  A language $L$ is in $\NNC(f(n))$ if there exists an \NC{} circuit family $\left\{C_n\right\}_{n \in \mathbb{N}}$, each circuit $C_n$ augmented with $O(f(n))$ nondeterministic guess gates, such that $x \in L$ if and only if $C_n(x)$ accepts.

  Alternatively a language $L$ is in $\NNC(f(n))$ if there exists an \NC{} circuit family $\left\{C_N\right\}_{N \in \mathbb{N}}$ such that for all strings $x$ of length $n$, we have $x \in L$ if and only if there exists a constant $c$ and a witness $\pi$ of length $c \cdot f(n)$ such that $C_{n + c \cdot f(n)}(x, \pi)$ outputs 1.
\end{definition}

\begin{proposition}[\cite{wolf94}]\label{prop:nnc}
  \mbox{}
  \begin{enumerate}
  \item $\NNC^k(\lg n) = \NC^k$ for all $k \in \mathbb{N}$.
  \item $\NNC(\lg n) = \NC$.
  \item $\NNC(\poly) = \NP$, and specifically $\NP \subseteq \NNC^1(\poly)$.
  \end{enumerate}
\end{proposition}

In \cite{wolf94}, the author conjectures that $\NNC(\polylog)$ is incomparable with $\P$ (but like \P, it resides between \NC{} and \NP).
We can get some of idea of the relationship between $\NNC(\polylog)$ and $\P$ from the following lemma and proposition.

\begin{lemma}[{{\cite[Lemma~3.2.8]{wolf90}}}]\label{lem:dspace}
  For all $k, j \in \mathbb{Q}$ with $k \geq 1$ and $j \geq 1$, we have $\NNC^k(\lg^j n) \subseteq \DSPACE(\lg^{\max(k, j)} n)$.
\end{lemma}

\begin{proposition}
  For all integers $k$ and $d$,
  \begin{enumerate}
  \item if a language $L$ is hard for $\NNC^k(\lg^d n)$ under $\leq_m^P$ reductions and $L \in \P$ then $\NNC^k(\lg^d n) \subseteq \P$, and
  \item if a language $L$ is hard for $\P$ under $\leq_m^{NC^k}$ reductions and $L \in \NNC^k(\lg^d n)$ then $\P \subseteq \NNC^k(\lg^d n)$.
    Furthermore $\P \subsetneq \polyL$.
  \end{enumerate}
\end{proposition}
\begin{proof}
  A standard simulation argument proves both statements.
  Since we have $\NNC^k(\lg^d n) \subseteq \DSPACE(\lg^m)$, where $m = \max(k, d)$, by \autoref{lem:dspace} and $\P \neq \polyL$ (by the Space Hierarchy Theorem), we conclude that $\P \subsetneq \polyL$.
\end{proof}

Now that we have the basic notions of nondeterministic circuits, we can return to our search for a restricted $\PCP$ characterization for $\NNC$ circuits.
Following the proof of \autoref{lem:pcpinnp}, we can show the following inclusion.
\begin{proposition}\label{prop:pcpinnnc}
  For all $j \in \mathbb{N}$ with $j \geq 0$, for all $k \in \mathbb{N}$ with $k \geq 1$ (\textbf{TODO can this be k = 1?}), and for all positive rationals $q$ and $r$,
  \begin{equation*}
    \PCPcs{\NC^k}{1}{\frac{1}{2}}{r \lg \lg n}{q \lg^j n} \subseteq \NNC^k(\lg^{r + j} n).
  \end{equation*}
\end{proposition}
\begin{proof}
  Let $L \in \PCPcs{\NC^k}{1}{\frac{1}{2}}{r \lg \lg n}{q \lg^j n}$.
  Let $V$ be the \PCP{} verifier for $L$ which, on input $x$ of length $n$, proof string $\pi$, and random string $\rho$, makes at most $q \lg^j n$ (nonadaptive) queries to the proof string and uses at most $r \lg \lg n$ random bits, and which satisfies
  \begin{enumerate}
  \item if $x \in L$, then there exists a $\pi$ of length $2^{r \lg \lg n} \cdot q \lg^j n$ such that
    \begin{equation*}
      \Pr_{\rho \in \Sigma^{r \lg \lg n}}{\left[V(x, \pi; \rho) \textnormal{ accepts}\right]} = 1,
    \end{equation*}
    and
  \item if $x \notin L$, then for all $\pi$ of length $2^{r \lg \lg n} \cdot q \lg^j n$,
    \begin{equation*}
      \Pr_{\rho \in \Sigma^{r \lg \lg n}}{\left[V(x, \pi; \rho) \textnormal{ accepts}\right]} < \frac{1}{2}.
    \end{equation*}
  \end{enumerate}
  Our goal is to construct a $\NNC^k(\lg^{r + j} n)$ machine which accepts $x$ if and only if $x \in L$ by simulating the \PCP{} verifier $V$.

  Define the $\NNC^k(\lg^{r + j} n)$ machine $M$ as follows on input $x$ of length $n$:
  \begin{enumerate}
  \item Guess a proof string $\pi$ of length $2^{r \lg \lg n} \cdot q \lg^j n$.
  \item For each $\rho$ of length $r \lg \lg n$ \emph{in parallel}, simulate $V(x, \pi; \rho)$ and let $b_\rho$ be its output bit.
  \item Let
    \begin{equation*}
      B = \sum_{\rho \in \Sigma^{r \lg \lg n}}{b_\rho},
    \end{equation*}
    and let
    \begin{equation*}
      B_0 = \frac{1}{2} 2^{r \lg \lg n}.
    \end{equation*}
  \item Accept if and only if $B \geq B_0$.
  \end{enumerate}

  First we show that $M$ can be implemented on a polynomial number of processors with parallel running time $\lg^k n$ and with at most $O(\lg^{j + r} n)$ nondeterministic gates.
  $M$ uses exactly $2^{r \lg \lg n}\cdot q \lg^j n$ nondeterministic gates (all in the first step), or more simply, $\lg^r n \cdot q \lg^j n$, which is in $O(\lg^{j + r} n)$.
  In step 2, $M$ runs $2^{r \lg \lg n}$, or more simply $\lg^r n$ (which is bounded above by a polynomial in $n$), instances of $V$ in parallel; the parallel running time of $V$ itself is $O(\lg^k)$, so the parallel running time of this step in $M$ is the same.
  In step 3, $M$ computes the sum of $2^{r \lg \lg n}$ numbers, or more simply $\lg^r n$ numbers (each a single bit, so the total size of $B$ is $\lg \lg^r n$, which equals $r \lg \lg n$), and computes the value of $\frac{1}{2} 2^{r \lg \lg n}$, or $\frac{1}{2} \lg^r n$.
  The sum of $\lg^r n$ numbers can be computed by an \NC{} circuit of size $O(\lg^r n)$ and depth $O(r \lg \lg n)$ \cite[Theorem~2.6.1]{savage98}.

  Now we show the correctness of $M$.
  If $x \in L$, then all instances of $V$ accept, so $B = \lg^r n \geq \frac{1}{2} \lg^r n = B_0$, and hence $M$ accepts.
  If $x \notin L$, then less than half of the instances of $V$ accept, so $B < \frac{1}{2} \lg^r n = B_0$, and hence $M$ rejects.
  Therefore we have shown that $M$ is a correct algorithm for $L$ which uses a polynomial number of processors, has $O(\lg^k n)$ running time, and uses $O(\lg^{j + r} n)$ nondeterministic gates.
  This concludes the proof.
\end{proof}

Note that there is some slack in this proof.
A polylogarithmic number of simulations of $V$ are being run in parallel, but an \NNC{} circuit could accomodate a polynomial number of simulations.
The number of simulations depends on the length of the random string $\rho$.
Since we will be interested only in the subclasses of $\NNC(\polylog)$, there must also be a polylogarithmic upper bound on the number of nondeterministic gates required, and hence the length of $\rho$ must be in $O(\lg \lg n)$.

\begin{corollary}
  For all $k \in \mathbb{N}$ with $k \geq 1$,
  \begin{enumerate}
  \item $\PCPcs{\NC^k}{1}{\frac{1}{2}}{0}{O(\lg n)} = \NNC^k(\lg n) = \NC^k$,
  \item $\PCPcs{\NC^k}{1}{\frac{1}{2}}{\lg \lg n}{O(1)} = \NNC^k(\lg n) = \NC^k$, and
  \item $\PCPcs{\NC^k}{1}{\frac{1}{2}}{O(\lg \lg n)}{O(\polylog)} \subseteq \NNC^k(\polylog)$.
  \end{enumerate}
\end{corollary}

\begin{corollary}\label{cor:pcpinnnc}
  \mbox{}
  \begin{enumerate}
  \item $\PCPcs{\NC}{1}{\frac{1}{2}}{0}{O(\lg n)} = \NNC(\lg n) = \NC$,
  \item $\PCPcs{\NC}{1}{\frac{1}{2}}{\lg \lg n}{O(1)} = \NNC(\lg n) = \NC$, and
  \item $\PCPcs{\NC}{1}{\frac{1}{2}}{O(\lg \lg n)}{O(\polylog)} \subseteq \NNC(\polylog)$.
  \end{enumerate}
\end{corollary}

\begin{corollary}
  For all $j \in \mathbb{N}$ with $j \geq 1$, for all $k \in \mathbb{N}$ with $k \geq 1$, and for all positive rationals $q$ and $r$,
  \begin{equation*}
    \PCPcs{\NC^k}{1}{\frac{1}{2}}{r \lg \lg n}{q \lg^j n} \subseteq \DSPACE(O(\lg^{\max(k, r + j)} n)).
  \end{equation*}

  Furthermore,
  \begin{equation*}
    \PCPcs{\NC}{1}{\frac{1}{2}}{O(\lg \lg n)}{O(\polylog)} \subseteq \polyL.
  \end{equation*}
\end{corollary}

\section{NNC in PCPs}

We intended to show $\NNC^k(\lg^d n) = \PCPcs{\NC^k}{1}{\frac{1}{2}}{d \lg \lg n}{O(1)}$, but it now seems unlikely that this is true.

\begin{theorem}\label{thm:equiv}
  For all $k \in \mathbb{N}$ with $k \geq 1$ (\textbf{TODO can this be k = 1?}), and for all positive rationals $q$ and $d$, the following are equivalent.
  \begin{enumerate}
  \item $\NNC^k(\lg^d n) = \NC^k$.
  \item $\NNC^k(\lg^d n) = \PCPcs{\NC^k}{1}{\frac{1}{2}}{d \lg \lg n + t}{q}$ for some non-negative integer $t$.
  \item There is an integer $c$ with $c > 1$ such that \textsc{$\frac{1}{2}$-gap $c$-CSP} is hard for $\NNC^k(\lg^d n)$ under $\leq_m^{NC^k}$ reductions that produce instances with $O(\lg^d n)$ variables and $O(\lg^d n)$ constraints.
  \end{enumerate}
\end{theorem}

The techniques used to prove this theorem immediately imply the following corollary.

\begin{corollary}
  The following are equivalent.
  \begin{enumerate}
  \item $\NNC(\polylog) = \NC$.
  \item $\NNC(\polylog) = \PCPcs{\NC}{1}{\frac{1}{2}}{O(\lg \lg n)}{O(1)}$.
  \item \textsc{$\frac{1}{2}$-gap $c$-CSP} is hard for $\NNC(\polylog)$ under $\leq_m^{NC}$ reductions that produce instances with $O(\polylog)$ variables and $O(\polylog)$ constraints, where $c$ is some integer greater than 1.
  \end{enumerate}
\end{corollary}

In order to prove this equivalence, we require the \NC{} analog of \autoref{prop:equivalence}, as well as some derandomization techniques.
Some of the theorems below are \NC{} analogs of results from \cite{fs96}.
We adapt the authors' presentation of derandomization using constant degree spectral expanders.
With this derandomization, we will show a simulation of $O(\lg \lg n)$ bits of randomness by $\lg \lg n + O(1)$ bits of randomness.
The derandomization requires a very explicit constant degree spectral expander.

\begin{definition}
  Suppose $d$ and $n$ are positive integers and $\lambda$ is a real number in the interval $(0, 1)$.
  Suppose $G_n$ is a $d$-regular directed multigraph on $n$ vertices and $M$ is the adjacency matrix of $G_n$.
  We say $G_n$ is a \emph{$\lambda$ spectral expander} if all but the largest eigenvalue of $\frac{1}{d}M$ are in the interval $(0, 1 - \lambda)$.
\end{definition}

The motivation behind the above definition is that the gap between the largest and second largest eigenvalues of the (normalized) adjacency matrix provides information about how quickly a random walk on the graph will approach the uniform distribution on the vertices of the graph.
Since we are concerned about the computational efficiency of such a random walk, it is important that computing the step from one vertex to the next can be performed quickly.

\begin{definition}
  We say a constant degree spectral expander with vertex set $V$ is \emph{very explicit} if each neighbor of a vertex can be computed in $O(\log |V|)$ time.
  (Compare this with the definition of a \emph{fully explicit} expander, in which the neighbor can be computed in time polynomial in $\log |V|$.)
\end{definition}

Infinite families of very explicit constant degree spectral expanders exist; for example, the construction due to Gabber and Galil \cite{gg79} satisfies the definition.

\begin{lemma}[{\cite{aks87}}]\label{lem:expander}
  Let $\mathcal{G}$ be an infinite family of constant degree spectral expanders and let $G_n \in \mathcal{G}$.
  For each subset $C$ of $V(G_n)$ with $|C| \leq \frac{|V(G_n)|}{16}$ there exists a constant $c$ such that for all positive integers $\kappa$, the probability that each $c$th step of a random walk on $G$ of length $\kappa c$ is in $C$ is at most $\frac{1}{2^\kappa}$.
\end{lemma}

\begin{lemma}\label{lem:badsubset}
  Let $L \in \PCPcs{\NC^k}{1}{\frac{1}{16}}{\alpha \lg \lg n}{O(1)}$ for some integer $\alpha$ greater than 1, and let $V$ be the corresponding \PCP{} verifier.
  Let $\ell = 2^{\lg \lg n}$.
  Let $x$ be a binary string of length $n$.
  Let $b(i)$ denote the binary representation of the non-negative integer $i$.
  Let $\mathcal{G}$ be an infinite family of constant degree spectral expanders, and let $G_\ell$ be the graph in $\mathcal{G}$ with $\ell$ nodes.
  There is a subset $C$ of $V(G_\ell)$ such that if the string $x$ is not in $L$ then for all proof strings $\pi$, there is a bijection between
  \begin{enumerate}
  \item the set of all strings $b(i_{1c}) \circ b(i_{2c}) \circ \dotsb \circ b(i_{\alpha c})$ such that $(v_{i_1}, \dotsc, v_{i_{\alpha c}})$ is a walk on $G_\ell$ and $v_{i_{jc}} \in C$ for all $j \in \{1, \dotsc, \alpha\}$ and
  \item the set of all strings $\rho \in \Sigma^{\alpha \lg \lg n}$ such that $V(x, \rho, \pi)$ accepts.
  \end{enumerate}
\end{lemma}
\begin{proof}
  If $x \notin L$, then for all $\pi$, the probability over all strings $\rho$ chosen uniformly at random that $V(x, \rho, \pi)$ accepts is strictly less than $\frac{1}{16}$, so there are less than $\frac{1}{16} 2^{\alpha \lg \lg n}$, such strings $\rho$.
  Call these strings ``bad''.
  Interpret each $\rho$ as $\rho_1 \circ \rho_2 \circ \dotsb \circ \rho_\alpha$, the concatenation of $\alpha$ binary strings, each of length $\lg \lg n$.
  Choose the subset $C$ to be the set of all vertices $v_i$ such that there is some bad string $\rho_1 \circ \dotsb \circ \rho_\alpha$ such that $b(i) = \rho_j$ for some $j \in \{1, \dotsc, \alpha\}$.
  In other words, the set $C$ contains all vertices whose binary representation appears in one of the substrings $\rho_j$ of some bad string.

  \textbf{TODO complete this proof.}
\end{proof}

By using a constant number of independent simulations of a \PCP{} verifier, we can achieve any constant soundness probability.

\begin{lemma}\label{lem:16}
  For all positive integers $k$, we have
  \begin{equation*}
    \PCPcs{\NC^k}{1}{\frac{1}{2}}{O(\lg \lg n)}{O(1)}
    \subseteq
    \PCPcs{\NC^k}{1}{\frac{1}{16}}{O(\lg \lg n)}{O(1)}.
  \end{equation*}
\end{lemma}

\begin{lemma}[{\cite[Lemma~4]{fs96}}]\label{lem:derandomize}
  For all integers $k$ where $k \geq 1$, we have
  \begin{equation*}
    \PCPcs{\NC^k}{1}{\frac{1}{2}}{O(\lg \lg n)}{O(1)}
    \subseteq
    \PCPcs{\NC^k}{1}{\frac{1}{2}}{\lg \lg n + O(1)}{O(1)}.
  \end{equation*}
\end{lemma}
\begin{proof}
  Let $L \in \PCPcs{\NC^k}{1}{\frac{1}{2}}{O(\lg \lg n)}{O(1)}$.
  $L$ is also in $\PCPcs{\NC^k}{1}{\frac{1}{16}}{O(\lg \lg n)}{O(1)}$ by \autoref{lem:16}.
  This means there exists a $(\alpha \lg \lg n, q)$-\PCP{} verifier $V$ for $L$, for some positive rational $\alpha$ and positive integer $q$, which has soundness probability $\frac{1}{16}$.
  We assume without loss of generality that $\alpha > 1$; if $\alpha \leq 1$ the statement is immediately true.
  Our goal is to construct a $(\lg \lg n + t, O(1))$-\PCP{} verifier $V'$ for $L$, for some constant integer $t$.
  Suppose for now that $t$ has been fixed; we will define it later in the proof.
  We construct the verifier $V'$ as follows on input $x$ of length $n$, random string $\rho$ of length $\lg \lg n + t$ and proof string $\pi$ of length $2^{\lg \lg n + t} q$ (this is the maximum number of possible bits of the proof string queried by a nonadaptive verifier with $\lg \lg n$ bits of randomness).
  Interpret $\rho$ as $\rho_1 \circ \rho_2$, where $|\rho_1| = \lg \lg n$ and $|\rho_2| = t$.

  Intuitively, the verifier will simulate $\alpha \lg \lg n$ random bits with only $\lg \lg n + t$ random bits by using a random walk on an expander graph.
  Let $\ell = 2^{\lg \lg n}$ and let $G_\ell$ be a $d$-regular very explicit spectral expander on $\ell$ vertices, for some positive integer $d$.
  Let $C$ be the subset of vertices guaranteed by \autoref{lem:badsubset}.
  Observe that the cardinality of $C$ is less than $\frac{|V(G_\ell)|}{16}$.
  By \autoref{lem:expander} there is a constant $c$ such that the probability that a random walk of length $\alpha c$ on $G_\ell$ arrives at a vertex in $C$ on every $c$th step is at most $\frac{1}{2^\alpha}$.
  We will be using such a random walk to simulate the randomness of $V$ and we want the soundness probability of $V'$ to be strictly less than $\frac{1}{2}$, so we will require the length of the walk to be strictly greater than $c$.

  Now we are ready to describe $V'$.
  \begin{enumerate}
  \item
    Perform a random walk of length $\alpha c$ on $G_\ell$ from an initial vertex chosen uniformly at random.
    Let $(v_{i_1}, \dotsc, v_{i_{\alpha c}})$ be the sequence of vertices that comprise this walk.
  \item
    Let $s = b(i_{1c}) \circ b(i_{2c}) \circ \dotsb \circ b(i_{\alpha c})$.
    Observe that $|s| = \alpha |b(i_k)| = \alpha \lg |V(G_\ell)| = \alpha \lg 2^{\lg \lg n} = \alpha \lg \lg n$.
  \item Accept if and only if $V(x, s, \pi)$ accepts.
  \end{enumerate}
  $V'$ requires $\lg \lg n$ random bits to choose an initial vertex for the walk and $\lg d$ random bits at each of the $\alpha c$ steps of the walk.
  Thus $V'$ uses $\lg \lg n + \alpha c \lg d$ random bits in total; now we define $t$ to be $\alpha c \lg d$, a constant independent of $n$.
  Since $V'$ only accesses the proof string $\pi$ via the simulation of $V$, the verifier $V'$ queries exactly the same number of bits of the proof string as does the verifier $V$.

  Performing a single step in a very explicit expander takes $O(|V(G_\ell)|)$ time.
  Thus, performing a random walk of length $\alpha c$ takes $O(\alpha c |V(G_\ell)|)$ time.
  Since $G_\ell$ has exactly $2^{\lg \lg n}$, or more simply $\lg n$, vertices, the total computation time for the random walk is $O(\alpha c \lg n)$, which is in $O(\lg n)$.
  Since $V$ is an $\NC^k$ algorithm, the simulation of $V$ can be performed by a polynomial size, $O(\log^k n)$ depth circuit.
  Therefore the overall time required by $V'$ is $O(\lg n) + O(\log^k n)$, which is in $O(\log^k n)$ for all $k \geq 1$.

  Now we show that $V'$ achieves the necessary completeness and soundness error bounds.
  Let $x$ be a string of length $n$, and $\pi$ be any sufficiently long proof string.
  By construction, we have
  \begin{equation*}
    \Pr_\rho[V'(x, \rho, \pi) \text{ accepts}] = \Pr_\rho[V(x, s, \pi) \text{ accepts}],
  \end{equation*}
  where $\rho$ is a binary string of length $\lg \lg n + t$ chosen uniformly at random, and $s$ is generated by the random walk on $G_\ell$ as described above.
  If $x \in L$, then there exists a proof string $\pi$ such that for all strings $\gamma$, we have $V(x, \gamma, \pi)$ accepts, and in particular, $V(x, s, \pi)$ accepts.
  Therefore, for all strings $\rho$, it follows that $V'(x, \rho, \pi)$ accepts.
  If $x \notin L$, then \autoref{lem:badsubset} applies, and we have
  \begin{align*}
    \Pr_\rho[V'(x, \rho, \pi) \text{ accepts}] & = \Pr_\rho[V(x, s, \pi) \text{ accepts}] \\
    & = \Pr_\rho[\forall j \in \{1, \dotsc, \alpha\} \colon v_{i_{jc}} \in C],
  \end{align*}
  where each $v_{i_{jc}}$ is a vertex on the random walk $(v_{i_1}, \dotsc, v_{i_{\alpha c}})$ from which $s$ is derived.
  This probability is at most $\frac{1}{2^\alpha}$ by \autoref{lem:expander}, which is strictly less than $\frac{1}{2}$ because $\alpha > 1$.

  To summarize, we have shown that $V'$ uses exactly $\lg \lg n + \alpha c \lg d$ bits of randomness, makes $O(1)$ queries to the proof string, can be implemented by an $\NC^k$ circuit, and has completeness 1 and soundness $\frac{1}{2}$.
  Therefore, $L \in \PCPcs{\NC^k}{1}{\frac{1}{2}}{\lg \lg n + O(1)}{O(1)}$.
\end{proof}

Using the derandomizations from \autoref{prop:pcpinnnc} and \autoref{lem:derandomize}, we can prove \autoref{thm:equiv}.
We divide the proof of the theorem into several lemmata.
The first lemma provides an \NC{} analog of \autoref{lem:constraintsp}.
The second lemma shows the equivalence of the first and second statements, and the third shows the equivalence of the second and third statements.

\begin{lemma}\label{lem:constraintsnc}
  Suppose $d$ and $t$ are non-negative integers.
  Let $L$ be a language in $\PCPcs{\NC^k}{1}{\frac{1}{2}}{d \lg \lg n + t}{O(1)}$.
  Then there is a $\leq_m^{NC^k}$ reduction from $L$ to \textsc{$\frac{1}{2}$-gap $q$-CSP}, for some integer $q$ greater than 1.
  Furthermore, the reduction yields $O(\lg^d n)$ variables and $O(\lg^d n)$ constraints on inputs of length $n$.
\end{lemma}
\begin{proof}
  The proof is similar to the proof of \autoref{lem:constraintsp}; the only difference is in the length of the random string $\rho$, and hence the size of the output of the reduction.
  Since the verifier $V$ now uses only $d \lg \lg n + t$ bits of randomness, the reduction enumerates (in parallel) each of the $2^{d \lg \lg n + t}$ possible random strings of length $d \lg \lg n + t$, instead of the $2^{r \lg n}$ possible strings of length $r \lg n$.
  Observe that the number of variables must be $q 2^{d \lg \lg n + t}$, which equals $q 2^t \lg^d n$, and the number of constraints is $2^t \lg^d n$, both members of $O(\lg^d n)$.
\end{proof}

\begin{lemma}\label{lem:1}
  For all positive integers $k$ and all non-negative rationals $d$, we have $\NNC^k(\lg^d n) = \NC^k$ if and only if there is a non-negative integer $z$ such that $\NNC^k(\lg^d n) = \PCPcs{\NC^k}{1}{\frac{1}{2}}{d \lg \lg n + z}{q}$.
\end{lemma}
\begin{proof}
  First, suppose $\NNC^k(\lg^d n) = \NC^k$.
  Then we have
  \begin{equation*}
    \NNC^k(\lg^d n)
    = \NC^k
    = \PCPcs{\NC^k}{1}{\frac{1}{2}}{0}{0}
    \subseteq \PCPcs{\NC^k}{1}{\frac{1}{2}}{d \lg \lg n}{q}.
  \end{equation*}
  Combine this with \autoref{prop:pcpinnnc} to achieve equality.
  In this case, we choose $z = 0$.

  For the converse, suppose $L$ is a language in $\NNC^k(\lg^d n)$.
  By hypothesis, $L \in \PCPcs{\NC^k}{1}{\frac{1}{2}}{d \lg \lg n + z}{q}$ for some non-negative integer $z$.
  Since $d \lg \lg n + z$ is in $O(\lg \lg n)$, we also have that $L \in \PCPcs{\NC^k}{1}{\frac{1}{2}}{d' \lg \lg n}{q}$ for some $d'$ greater than or equal to $d$.
  By \autoref{lem:derandomize}, there exists a $t$ such that $L \in \PCPcs{\NC^k}{1}{\frac{1}{2}}{\lg \lg n + t}{q}$.
  By \autoref{lem:constraintsnc}, there exists an integer $q$ greater than 1 such that $L$ reduces to \textsc{$\frac{1}{2}$-gap $q$-CSP} under a $\leq_m^{NC^k}$ reduction that produces an instance with $O(\lg n)$ variables and $O(\lg n)$ constraints; let $f$ be the function which computes this reduction.
  We construct an $\NC^k$ algorithm for $L$ as follows on input $x$ of length $n$.
  \begin{enumerate}
  \item Compute $f(x)$, which yields alphabet $\Gamma$, set of variables $U$, and set of constraints $D$.
  \item For each pair $(\alpha, C)$, where $\alpha$ is a truth assignment to $U$ and $C$ is a constraint in $D$, evaluate the constraint $C$ with respect to truth assignment $\alpha$.
  \item Accept if and only if there exists a truth assignment for which all constraints in $D$ are satisfied.
  \end{enumerate}

  First we show that this algorithm can be computed by an $\NC^k$ circuit family.
  Computing $f$ can be performed in $\NC^k$.
  There are a polynomial number of truth assignments to the $O(\lg n)$ variables of $U$, and there are only $O(\lg n)$ constraints in $D$, so the second step requires only a polynomial number of parallel sub-circuits.
  Boolean constraint evaluation can be performed in logarithmic space with respect to the length of the input, and in this case the length of the input is the size of a constraint (which is constant, since each constraint depends on at most $q$ variables).
  The circuit concludes with a polynomial number of parallel conjunction gates, each of which computes the conjunction of the result of evaluating each constraint for a single assignment, followed by a single gate computing the disjunction of all the conjunctions.
  All steps after the first add only constant depth to the overall circuit, and the number of gates is polynomial in $n$, so this is indeed an $\NC^k$ circuit.

  It remains to show that this algorithm is correct.
  For all strings $x$, we know $x$ is in $L$ if and only if $f(x)$ is in \textsc{$\frac{1}{2}$-gap $q$-CSP}.
  In fact, the procedure defined by steps 2 and 3 together is a correct algorithm for the more general constraint satisfaction problem.
  If all constraints in $D$ are satisfiable, then there is some assignment to $U$ which satisfies all of them, and the final disjunction must be true.
  Conversely, if some of the constraints in $D$ are not satisfiable, then no assignment satisfies all of them, so the final disjunction must be false.
  Therefore $x$ is in $L$ if and only if the algorithm accepts.

  Finally, we conclude that the given algorithm is a correct $\NC^k$ algorithm for an arbitrary language $L$ in $\NNC^k(\lg^d n)$, and hence $\NNC^k(\lg^d n) = \NC^k$.
\end{proof}

\begin{lemma}\label{lem:2}
  For all positive integers $k$ and all non-negative rationals $d$, $\NNC^k(\lg^d n) = \PCPcs{\NC^k}{1}{\frac{1}{2}}{d \lg \lg n + t}{q}$ for some non-negative integer $t$ if and only if there exists an integer $c$ with $c > 1$ such that \textsc{$\frac{1}{2}$-gap $c$-CSP} is hard for $\NNC^k(\lg^d n)$ under $\leq_m^{NC^k}$ reductions that produce instances with $O(\lg^d n)$ variables and $O(\lg^d n)$ constraints.
\end{lemma}
\begin{proof}
  One direction of the equivalence follows immediately \autoref{lem:constraintsnc}.
  Thus it suffices to prove the converse implication.
  The proof is nearly the same as the proof of \autoref{prop:equivalence}; the only difference is in the length of the random string $\rho$, and hence the size of the output of the reduction.
  Observe that the PCP verifier in the proof that the latter statement implies the former requires $d \lg \lg n + \lg c$ bits of randomness to select one of the $c \lg^d n$ constraints uniformly at random, where $c$ is a constant, so we choose $t = \lg c$.
  To prove the other direction of the inclusion and complete the proof, we apply \autoref{prop:pcpinnnc}.
\end{proof}

\autoref{thm:equiv} follows immediately from \autoref{lem:1} and \autoref{lem:2}.

\bibliographystyle{plain}
\bibliography{references}

\end{document}
