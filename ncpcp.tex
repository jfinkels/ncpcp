\documentclass{article}

% Package `amsthm` and `thmtools` must come before package `hyperref`.
\usepackage{amsthm}
\usepackage{thmtools}
% Package `hyperref` must come before package `complexity`.
\usepackage[pdftitle={Restricted probabilistically checkable proofs}, pdfauthor={Jeffrey Finkelstein}]{hyperref}
\usepackage{complexity}
\usepackage{amsmath}
\usepackage{amssymb}

\declaretheorem[numberwithin=section]{theorem}
\declaretheorem[numberlike=theorem]{corollary}
\declaretheorem[numberlike=theorem]{lemma}
\declaretheorem[numberlike=theorem]{proposition}
\declaretheorem[numberlike=theorem, style=definition]{construction}
\declaretheorem[numberlike=theorem, style=definition]{definition}

%% Arguments:
%%  1. Complexity class of the verifier
%%  2. Completeness probability
%%  3. Soundness probability
%%  4. Randomness
%%  5. Number of queries
\newcommand{\PCPcs}[5]{\PCP^{#1}_{#2, #3}\left[#4, #5\right]}
\newcommand{\loglog}{\log \log}
\newcommand{\email}[1]{\href{mailto:#1}{\nolinkurl{#1}}}

\newenvironment{proofidea}{\begin{proof}[Proof~idea]}{\end{proof}}

\title{Restricted probabilistically checkable proofs}
\author{Jef{}frey~Finkelstein}
\date{\today}

\begin{document}
\maketitle

\section{Introduction}

In this work we provide some initial structural complexity results for classes of probabilistically checkable proof systems (PCPs) for nondeterministic \NC{} (\NNC) circuit families, as a first step towards characterizing probabilistic proof systems for \P.
One of the major successes of the characterization of \NP{} as a class of PCPs (with polynomial time verifiers) is that it provides a route to proving that approximating certain computationally intractable optimization problems is as difficult as solving them exactly.
The growth of multiprocessor systems in general purpose personal computers highlights the urgency of proving the analagous inapproximability (or approximability) of \emph{inherently sequential} optimization problems by \emph{highly parallel} algorithms.
The \P-complete problems are generally considered to be inherently sequential, whereas problems in \NC{} are considered highly parallel.
Our guiding question is now, ``For which \P-complete problems are there \NC{} approximation algorithms, and for which are there none?''

Unfortunately, the techniques used to prove the original PCP Theorem rely on the fact that \NP{} can be interpreted as the class of languages for which there is an efficient verification procedure given a brief witness to language membership; no such obvious interpretation of \P{} exists.
Indeed, this question was already on the minds of researchers soon after the original proof of the PCP Theorem.
\begin{quote}
  An intriguing question is whether the known non-approximability results for sequential algorithms can be improved when we restrict to \NC{} algorithms (under the assumption that $\P \neq \NC$).
  A possible way may be to devise \emph{probabilistic proof systems for \P} more efficient that the currently known proof systems for \NP.
  Such a result would have a great independent interest.
  However, it is not clear why proofs for \P{} should be \emph{easier to check} than proofs for \NP{} (they only appear to be \emph{easier to generate}). \cite{trevisan98}
\end{quote}
Perhaps \P{} has proof systems which are easy to check in \NC, but this remains unclear.
Instead, we consider proof systems for the class $\NNC(\polylog)$, the class of languages decidable by \NC{} circuit families augmented with a polylogarithmic number of nondeterministic gates.
We hope that this will be a valuable first step toward understanding proof systems for \P.
We consider $\NNC(\polylog)$ for two reasons.
First, it is defined in such a way that it explicitly has short proof systems which are easy to verify in parallel, just as \NP{} is defined in such a way that it explicitly has short proof systems which are easy to verify efficiently.
Second, it, like \P, lies between \NC{} and \NP{}.

Although our original intention was to show a result like $\NNC(\polylog) = \PCP[O(\loglog n), O(1)]$, our research reveals that proving such an equality is equivalent to proving $\NNC(\polylog) = \NC$, or in other words, that a polylogarithmic amount of nondeterminism can be simulated deterministically by an \NC{} circuit family.
This should be seen as evidence that such a result is unlikely; in fact, we show that such a simulation implies a deterministic subexponential time algorithm for \textsc{Satisfiability}!
We are still, however, able to show that certain PCP classes are contained in $\NNC(\polylog)$.

\section{Preliminaries}

Throughout this work, $\log n$ denotes the base 2 logarithm of $n$.

We assume the reader knows the basic definitions from complexity theory, including those of \P, \NP, \DTIME, and \DSPACE.
We will also be considering the $\NC^k$, the class of languages decidable by a family of logarithmic space uniform Boolean circuits of polynomial size, $O(\log^k n)$ depth, and unbounded fan-in.
We will denote by $\NC$ the union of all the $\NC^k$ classes.

\begin{definition}
  For all functions $f, g \colon \mathbb{N} \to \mathbb{R}$, the function $f$ is in the class $O(g(n))$ if there exist real numbers $c$ and $N$ such that for all natural numbers $n$ we have $n > N$ implies $f(n) \leq c \cdot g(n)$.
  If $f(n) < c \cdot g(n)$ then $f(n)$ is in $o(g(n))$.
  If $f(n) \geq c \cdot g(n)$ then $f(n)$ is in $\Omega(g(n))$.
  If $f(n) > c \cdot g(n)$ then $f(n)$ is in $\omega(g(n))$.
\end{definition}

\begin{definition}[{{\cite[Definition~1.1]{dinur07}}}]
  Let $V$ be a finite set of variables, defined by $V = \{x_1, x_2, \dotsc, x_n\}$, let $\Gamma$ be a finite alphabet, and let $q$ be a natural number.
  A \emph{$q$-ary constraint} is a $q + 1$ tuple, $(C, i_1, i_2, \dotsc, i_q)$, where $C \subseteq \Gamma^q$ and $i_k \in \{1, 2, \dotsc, n\}$ for all $k \in \{1, 2, \ldots, q\}$.
  Here, $C$ is considered the set of ``acceptable'' values for the variables.

  An \emph{assignment} is a function $a \colon V \to \Gamma$.
  An assignment \emph{satisfies} a constraint if $(a(v_{i_1}), a(v_{i_2}), \dotsc, a(v_{i_q})) \in C$.
\end{definition}

\begin{definition}[\textsc{$\frac{1}{2}$-gap $q$-CSP}]
  \mbox{}

  \textbf{Instance:} finite alphabet $\Gamma$ with $|\Gamma| > 1$, finite set of variables $V$, finite set of $q$-ary constraints $D$ with the restriction that for any assignment, either all constraints are satisfied or fewer than half are.

  \textbf{Question:} Are all constraints in $D$ satisfiable?
\end{definition}

\begin{definition}
  A \emph{PCP verifier} is a probabilistic Turing machine which has sequential access to an input string $x$, sequential access to a random string $\rho$, and \emph{nonadaptive random access} to a proof string $\pi$.
\end{definition}

The initialism ``PCP'' stands for ``probabilistically checkable proof''.

\begin{definition}
  Let $r(n)$ and $q(n)$ be bounded above by polynomials in $n$, and let $c(n)$ and $s(n)$ be functions whose values are in the interval $[0, 1]$.
  A language $L$ has a $(r(n), q(n), c(n), s(n))$-\emph{PCP verifier} if there exists a PCP verifier $V$ such that $V$ uses at most $r(n)$ bits of the random string $\rho$, makes at most $q(n)$ \emph{nonadaptive} queries to bits of the proof $\pi$, and satisfies the following conditions.
  \begin{enumerate}
  \item If $x \in L$, then
    \begin{equation*}
      \exists \pi \in \Sigma^* \colon \Pr_{\rho \in \Sigma^{r(n)}}{\left[V(x, \pi; \rho) \textnormal{ accepts}\right]} \geq c(n).
    \end{equation*}
  \item If $x \notin L$, then
    \begin{equation*}
      \forall \pi \in \Sigma^* \colon \Pr_{\rho \in \Sigma^{r(n)}}{\left[V(x, \pi; \rho) \textnormal{ accepts}\right]} < s(n).
    \end{equation*}
  \end{enumerate}
  The value $c(n)$ is the \emph{completeness} and the value $s(n)$ the \emph{soundness} of the verifier.
\end{definition}

In this work, we will consider only nonadaptive PCP verifiers.
Since a (nonadaptive) $(r(n), q(n), c(n), s(n))$-PCP verifier can read at most $2^{r(n)} q(n)$ locations of the proof string with nonzero probability, we assume without loss of generality that the proof provided to the verifier is of length at most $2^{r(n)} q(n)$ \cite[Remark~11.6]{ab09}.
(Note that a verifier which uses $q(n)$ adaptive random access queries to the proof string can be simulated by a verifier which uses $2^{q(n)}$ nonadaptive random access queries to the proof string, so in the adaptive case, the proof string could be of length $2^{r(n) + q(n)}$.)

\begin{definition}
  Let $\PCPcs{\mathcal{C}}{c(n)}{s(n)}{r(n)}{q(n)}$ be the class of all languages $L$ such that $L$ has a $(r(n), q(n), c(n), s(n))$-PCP verifier $V$ computable by a $\mathcal{C}$ algorithm.

  More generally, if $\mathcal{F}$ and $\mathcal{G}$ are classes of functions,
  \begin{equation*}
    \PCPcs{\mathcal{C}}{c(n)}{s(n)}{\mathcal{F}}{\mathcal{G}} = \bigcup_{f \in \mathcal{C}, g \in \mathcal{G}}{\PCPcs{\mathcal{C}}{c(n)}{s(n)}{f(n)}{g(n)}},
    \end{equation*}

  Since completeness 1 and soundness $\frac{1}{2}$ are common parameters, and for the sake of brevity, we write $\PCP^{\mathcal{C}}[r(n), q(n)]$ to denote $\PCPcs{\mathcal{C}}{1}{\frac{1}{2}}{r(n)}{q(n)}$, and $\PCP^{\mathcal{C}}[\mathcal{F}, \mathcal{G}]$ to denote $\PCPcs{\mathcal{C}}{1}{\frac{1}{2}}{\mathcal{F}}{\mathcal{G}}$.
\end{definition}

Please notice that the complexity class given in the superscript in the above definition does \emph{not} denote an oracle; it merely describes the computational power of the PCP verifier.

From the definition, we see immediately that
\begin{equation*}
  \PCPcs{\mathcal{C}}{c(n)}{s{n}}{O(r(n))}{O(q(n))} = \bigcup_{a \in \mathbb{N}, b \in \mathbb{N}}{\PCPcs{\mathcal{C}}{c(n)}{s(n)}{a \cdot r(n)}{b \cdot q(n)}}.
\end{equation*}

\section{Probabilistically checkable proofs for nondeterministic circuits}

First, consider the chain of inclusions
\begin{equation*}
  \NNC(\log n) \subseteq \NNC(\polylog) \subseteq \NNC(\poly).
\end{equation*}
In fact, $\NC = \NNC(\log n)$ and $\NNC(\poly) = \NP$ \cite{wolf94}, so we can rewrite this as
\begin{equation}\label{eq:chain}
  \NC \subseteq \NNC(\polylog) \subseteq \NP.
\end{equation}
In subsequent sections, we will show that $\NC = \PCP^\NC[O(\loglog n), O(1)]$ and $\PCP^\NC[O(\log n), O(1)] = \NP$, which together yield
\begin{equation}\label{eq:pcpchain}
  \PCP^\NC[O(\loglog n), O(1)] \subseteq \NNC(\polylog) \subseteq \PCP^\NC[O(\log n), O(1)].
\end{equation}
We first provide evidence that the inclusions in \autoref{eq:chain} are strict.
From this and \autoref{eq:pcpchain}, we will infer that any restricted PCP characterization (with a constant number of proof queries) of $\NNC(\polylog)$ likely requires PCP verifiers that use $\omega(\loglog n)$ bits and $o(\log n)$ bits of randomness. Note that \P{} can replace $\NNC(\polylog)$ in any of the above inclusion chains, so the same conclusion holds for \P.
(On the other hand, it is conjectured that \P{} and $\NNC(\polylog)$ are incomparable \cite{wolf94}.)

\begin{theorem}
  If $\NC = \NNC(\polylog)$ or $\NNC(\polylog) = \NP$, then $\NP \subseteq \SUBEXP$.
\end{theorem}
\begin{proof}
  If $\NNC(\polylog) = \NP$, then
  \begin{align*}
    \NP & \subseteq \NNC(\polylog) \\
        & \subseteq \NNC(\log^k n), \text{for some } k & \text{(by definition)}\\
        & \subseteq \DSPACE(\log^k n) & \text{(by \cite{wolf94})} \\
        & \subseteq \DTIME(2^{\log^k n}) & \text{(by exhaustive search)} \\
        & \subseteq \SUBEXP,
  \end{align*}
  where the last relation holds because $O(2^{\log^k n})$ is in $O(2^{n^\epsilon})$ for all (small) positive epsilon and for sufficiently large $n$.
  Now suppose $\NC = \NNC(\polylog)$.
  Since \textsc{Satisfiability} is complete for $\NP$ under deterministic polynomial time many-one reductions, it suffices to show a deterministic subexponential time algorithm for \textsc{Satisfiability}.

  The proof uses a padding argument.
  First we observe that there is an $\NNC^1(n)$ machine, call it $M$, that decides \textsc{Satisfiability}: given a Boolean formula $\phi$, guess a satisfying assignment to $\phi$ (of length $O(n)$) and evaluate the formula (Boolean formula evaluation is in $\NC^1$ \cite{buss87}).
  Let $\epsilon$ be an arbitrarily small positive constant, and define $L$, the padded version of \textsc{Satisfiability}, as
  \begin{equation*}
    L = \left\{ \phi \# 1^P \, \middle| \, \phi \in \textsc{Satisfiability} \text{ and } P = 2^{n^\epsilon} - (n + 1) \right\},
  \end{equation*}
  where $n = |\phi|$.
  We claim $L$ is in $\NNC(\log^\frac{1}{\epsilon} n)$ by the following machine, $M_j$.
  On input $\phi'$, check that $\phi'$ is in the format $\phi \# 1^P$, then accept if and only if $M$ accepts $\phi$.
  The correctness of this algorithm follows from the correctness of $M$, so it remains to check the size and depth of the circuit for $M_j$, and the amount of nondeterminism used.

  Checking that $x'$ is in the correct format can be performed (deterministically) by an $\NC^0$ circuit by computing the conjunction of all the bits after the $\#$ symbol.
  Observe now that $|x'| = 2^{n^\epsilon}$, so $n = \log^\frac{1}{\epsilon}{|x'|}$.
  The amount of nondeterminism used by $M_j$ is the same as the amount used by $M$, which is $O(n)$, or $O(\log^\frac{1}{\epsilon} |x'|)$.
  The size of $M$ is polynomial in $n$, which is polylogarithmic in $|x'|$, and hence polynomial in the length of the input $x'$.
  The depth of $M$ is $O(\log n)$, which is $O(\log \log^\frac{1}{\epsilon} |x'|)$, or simply $O(\log \log |x'|)$.
  We conclude that the size of $M_j$ is polynomial in $|x'|$, the depth of $M_j$ is logarithmic in $|x'|$, and $M_j$ uses $O(\log^\frac{1}{\epsilon} |x'|)$ bits of nondeterminism.
  Hence $L$ is in $\NNC(\log^\frac{1}{\epsilon} n)$.

  By hypothesis, $L$ is also in $\NC$.
  Let $M_i$ be the $\NC$ machine that decides it.
  We claim that we can now construct a subexponential time algorithm for \textsc{Satisfiability} on inputs $\phi$ of length $n$.
  \begin{enumerate}
  \item Let $\phi' = \phi \# 1^P$, where $P = 2^{n^\epsilon} - (n + 1)$.
  \item Accept if and only if $M_i$ accepts $\phi'$.
  \end{enumerate}
  The correctness of this algorithm follows immediately from the correctness of $M_i$.
  The first step can be performed by a deterministic algorithm running in time $2^{n^\epsilon}$.
  The second step can be performed by an $\NC$ machine.
  Since $\NC \subseteq \P$, and $2^{n^\epsilon}$ is greater than any polynomial for sufficiently large $n$, the first step is the bottleneck in this algorithm.
  Therefore, this algorithm for \textsc{Satisfiability} can be implemented by a deterministic algorithm running in $O(2^{n^\epsilon})$ time for arbitrarily small $\epsilon$.
\end{proof}

Next we turn to the restricted PCP characterizations for \NC{} and \NP{}.

\subsection{Restricted PCP characterization of \texorpdfstring{\NC}{NC}}

The strategy for proving that $\NC = \PCP^\NC[O(\loglog n), O(1)]$ is to simulate the $O(\loglog n)$ bits of randomness using only $\loglog n + t$ bits, which can then be enumerated by an $\NC$ machine.
We adapt to the \NC{} setting the derandomization using constant degree spectral expanders from \cite{fs96}.
The derandomization requires a fully explicit constant degree spectral expander.

\begin{definition}
  Suppose $d$ and $n$ are positive integers and $\lambda$ is a real number in the interval $(0, 1)$.
  Suppose $G_n$ is a $d$-regular directed multigraph on $n$ vertices and $M$ is the adjacency matrix of $G_n$.
  We say $G_n$ is a \emph{$\lambda$ spectral expander} if all but the largest eigenvalue of $\frac{1}{d}M$ are in the interval $(0, 1 - \lambda)$.
\end{definition}

The motivation behind the above definition is that the gap between the largest and second largest eigenvalues of the (normalized) adjacency matrix provides information about how quickly a random walk on the graph will approach the uniform distribution on the vertices of the graph.
Since we are concerned about the computational efficiency of such a random walk, it is important that computing the step from one vertex to the next can be performed quickly.

\begin{definition}
  We say a constant degree spectral expander with vertex set $V$ is \emph{fully explicit} if each neighbor of a vertex can be computed in time polynomial in $O(\log |V|)$.
\end{definition}

Infinite families of fully explicit constant degree spectral expanders exist; for example, the construction due to Gabber and Galil \cite{gg79} satisfies the definition.

\begin{lemma}[{\cite{aks87}}]\label{lem:expander}
  Let $\mathcal{G}$ be an infinite family of constant degree spectral expanders and let $G_n \in \mathcal{G}$.
  For each subset $C$ of $V(G_n)$ with $|C| \leq \frac{|V(G_n)|}{16}$ there exists a constant $c$ such that for all positive integers $\kappa$, the probability that each $c$th step of a random walk on $G$ of length $\kappa c$ is in $C$ is at most $\frac{1}{2^\kappa}$.
\end{lemma}

We omit the proof of the above lemma because it is not relevant to the discussion.

\begin{lemma}\label{lem:badsubset}
  Let $L \in \PCPcs{\NC}{1}{\frac{1}{16}}{\alpha \loglog n}{O(1)}$ for some integer $\alpha$ greater than 1, and let $V$ be the corresponding PCP verifier.
  Let $\ell = 2^{\loglog n}$.
  Let $x$ be a binary string of length $n$.
  Let $b(i)$ denote the binary representation of the non-negative integer $i$.
  Let $\mathcal{G}$ be an infinite family of constant degree spectral expanders, and let $G_\ell$ be the graph in $\mathcal{G}$ with $\ell$ nodes.
  There is a subset $C$ of $V(G_\ell)$ such that if the string $x$ is not in $L$ then for all proof strings $\pi$, there is a bijection between
  \begin{enumerate}
  \item the set of all strings $b(i_{1c}) \circ b(i_{2c}) \circ \dotsb \circ b(i_{\alpha c})$ such that $(v_{i_1}, \dotsc, v_{i_{\alpha c}})$ is a walk on $G_\ell$ and $v_{i_{jc}} \in C$ for all $j \in \{1, \dotsc, \alpha\}$ and
  \item the set of all strings $\rho \in \Sigma^{\alpha \loglog n}$ such that $V(x, \rho, \pi)$ accepts.
  \end{enumerate}
\end{lemma}
\begin{proof}
  If $x \notin L$, then for all $\pi$, the probability over all strings $\rho$ chosen uniformly at random that $V(x, \rho, \pi)$ accepts is strictly less than $\frac{1}{16}$, so there are less than $\frac{1}{16} 2^{\alpha \loglog n}$, such strings $\rho$.
  Call these strings ``bad''.
  Interpret each $\rho$ as $\rho_1 \circ \rho_2 \circ \dotsb \circ \rho_\alpha$, the concatenation of $\alpha$ binary strings, each of length $\loglog n$.
  Choose the subset $C$ to be the set of all vertices $v_i$ such that there is some bad string $\rho_1 \circ \dotsb \circ \rho_\alpha$ such that $b(i) = \rho_j$ for some $j \in \{1, \dotsc, \alpha\}$.
  In other words, the set $C$ contains all vertices whose binary representation appears in one of the substrings $\rho_j$ of some bad string.

  \textbf{TODO complete this proof.}
\end{proof}

By using a constant number of independent simulations of a PCP verifier, we can achieve any constant soundness probability.

\begin{lemma}\label{lem:16}
  $\PCPcs{\NC}{1}{\frac{1}{2}}{O(\loglog n)}{O(1)} \subseteq \PCPcs{\NC}{1}{\frac{1}{16}}{O(\loglog n)}{O(1)}$.
\end{lemma}

Using the soundness amplification from \autoref{lem:16} and the random walk from \autoref{lem:expander}, we can show how to simulate $O(\loglog n)$ bits of randomness with only $\loglog n + O(1)$ bits.
%% TODO use a generic pseudorandom generator here?

\begin{lemma}[{\cite[Lemma~4]{fs96}}]\label{lem:derandomize}
  \begin{equation*}
    \PCP^\NC[O(\loglog n), O(1)] = \PCP^\NC[\loglog n + O(1), O(1)].
  \end{equation*}
\end{lemma}
\begin{proof}
  One inclusion follows immediately from the definitions.
  For the other, let $L \in \PCP^\NC[O(\loglog n), O(1)]$.
  By \autoref{lem:16}, we know that $L$ is also in $\PCPcs{\NC}{1}{\frac{1}{16}}{O(\loglog n)}{O(1)}$.
  This means there exists a $(\alpha \loglog n, q, 1, \frac{1}{16})$-PCP verifier $V$ for $L$, for some positive rational $\alpha$ and positive integer $q$.
  We assume without loss of generality that $\alpha > 1$; if $\alpha \leq 1$ the statement is immediately true.
  Our goal is to construct a $(\loglog n + t, O(1), 1, \frac{1}{2})$-PCP verifier $V'$ for $L$, for some constant integer $t$.
  Suppose for now that $t$ has been fixed; we will define it later in the proof.
  We construct the verifier $V'$ as follows on input $x$ of length $n$, random string $\rho$ of length $\loglog n + t$ and proof string $\pi$ of length $2^{\loglog n + t} q$ (this is the maximum number of possible bits of the proof string queried by a nonadaptive verifier with $\loglog n$ bits of randomness).
  Interpret $\rho$ as $\rho_1 \circ \rho_2$, where $|\rho_1| = \loglog n$ and $|\rho_2| = t$.

  Intuitively, the verifier $V'$ that we construct will simulate $\alpha \loglog n$ random bits with only $\loglog n + t$ random bits by using a random walk on an expander graph.
  Let $\ell = 2^{\loglog n}$ and let $G_\ell$ be a $d$-regular fully explicit spectral expander on $\ell$ vertices, for some positive integer $d$.
  Let $C$ be the subset of vertices guaranteed by \autoref{lem:badsubset}.
  Observe that the cardinality of $C$ is less than $\frac{|V(G_\ell)|}{16}$.
  By \autoref{lem:expander} there is a constant $c$ such that the probability that a random walk of length $\alpha c$ on $G_\ell$ arrives at a vertex in $C$ on every $c$th step is at most $\frac{1}{2^\alpha}$.

  Now we are ready to describe $V'$.
  \begin{enumerate}
  \item
    Perform a random walk of length $\alpha c$ on $G_\ell$ from an initial vertex chosen uniformly at random.
    Let $(v_{i_1}, \dotsc, v_{i_{\alpha c}})$ be the sequence of vertices that comprise this walk.
  \item
    Let $s = b(i_{1c}) \circ b(i_{2c}) \circ \dotsb \circ b(i_{\alpha c})$.
    Observe that $|s| = \alpha |b(i_k)| = \alpha \log |V(G_\ell)| = \alpha \log 2^{\loglog n} = \alpha \loglog n$.
  \item Accept if and only if $V(x, s, \pi)$ accepts.
  \end{enumerate}
  $V'$ requires $\loglog n$ random bits to choose an initial vertex for the walk and $\log d$ random bits at each of the $\alpha c$ steps of the walk.
  Thus $V'$ uses $\loglog n + \alpha c \log d$ random bits in total; now we define $t$ to be $\alpha c \log d$, a constant independent of $n$.
  Since $V'$ only accesses the proof string $\pi$ via the simulation of $V$, the verifier $V'$ queries exactly the same number of bits of the proof string as does the verifier $V$.

  Performing a single step in a fully explicit expander takes $p(|V(G_\ell)|)$ time for some polynomial $p$.
  Thus, performing a random walk of length $\alpha c$ takes $p(\alpha c |V(G_\ell)|)$ time.
  Since $G_\ell$ has exactly $2^{\loglog n}$, or more simply $\log n$, vertices, the total computation time for the random walk is $O(p(\alpha c \log n))$, which is polylogarithmic in $n$.
  Since $V$ is an $\NC$ algorithm, the simulation of $V$ can be performed by a polynomial size, polylogarithmic depth circuit.
  Therefore the overall time required by $V'$ is polylogarithmic in $n$.

  Now we show that $V'$ achieves the necessary completeness and soundness error bounds.
  Let $x$ be a string of length $n$, and $\pi$ be any sufficiently long proof string.
  By construction, we have
  \begin{equation*}
    \Pr_\rho[V'(x, \rho, \pi) \text{ accepts}] = \Pr_\rho[V(x, s, \pi) \text{ accepts}],
  \end{equation*}
  where $\rho$ is a binary string of length $\loglog n + t$ chosen uniformly at random, and $s$ is generated by the random walk on $G_\ell$ as described above.
  If $x \in L$, then there exists a proof string $\pi$ such that for all strings $\gamma$, we have $V(x, \gamma, \pi)$ accepts, and in particular, $V(x, s, \pi)$ accepts.
  Therefore, for all strings $\rho$, it follows that $V'(x, \rho, \pi)$ accepts.
  If $x \notin L$, then \autoref{lem:badsubset} applies, and we have
  \begin{align*}
    \Pr_\rho[V'(x, \rho, \pi) \text{ accepts}] & = \Pr_\rho[V(x, s, \pi) \text{ accepts}] \\
    & = \Pr_\rho[\forall j \in \{1, \dotsc, \alpha\} \colon v_{i_{jc}} \in C],
  \end{align*}
  where each $v_{i_{jc}}$ is a vertex on the random walk $(v_{i_1}, \dotsc, v_{i_{\alpha c}})$ from which $s$ is derived.
  This probability is at most $\frac{1}{2^\alpha}$ by \autoref{lem:expander}, which is strictly less than $\frac{1}{2}$ because $\alpha > 1$.

  To summarize, we have shown that $V'$ uses exactly $\loglog n + \alpha c \log d$ bits of randomness, makes $O(1)$ queries to the proof string, can be implemented by an $\NC$ circuit, and has completeness 1 and soundness $\frac{1}{2}$.
  Therefore, $L \in \PCP^\NC[\loglog n + O(1), O(1)]$.
\end{proof}

Now that we have a restricted PCP verifier using only $\loglog n + O(1)$ bits of randomness, we show how an \NC{} machine can enumerate all possible random strings.

\begin{lemma}\label{lem:pcpinnnc}
  $\PCP^\NC[\loglog n + O(1), O(1)] = \NC$.
\end{lemma}
\begin{proof}
  One inclusion follows immediately from the definitions.
  For the other, let $L \in \PCP^\NC[\loglog n + t, q]$ for some non-negative integers $t$ and $q$.
  Let $V$ be the PCP verifier for $L$ which, on input $x$ of length $n$, proof string $\pi$, and random string $\rho$, makes at most $q$ (nonadaptive) queries to the proof string and uses at most $\loglog n + t$ random bits, and which has completeness probability 1 and soundness probability $\frac{1}{2}$.
  Construct an \NC{} machine $M$ as follows on input $x$ of length $n$.
  \begin{enumerate}
  \item For each proof string $\pi$ of length $q 2^{\loglog n + t}$ \emph{in parallel}, and for each $\rho$ of length $\loglog n + t$ \emph{in parallel}, simulate $V(x, \pi; \rho)$.
  \item Accept if and only if at least half of the simulations accept.
  \end{enumerate}

  First we show that $M$ can be implemented on a circuit with a polynomial number of processors and a polylogarithmic depth.
  The size of the proof string $\pi$ is $q 2^t \log n$, and the size of the random string $\rho$ is $\loglog n + t$.
  The total number of possible pairs of proof string and random string is $2^{q 2^t \log n} 2^{\loglog n + t}$, which equals $2^t n^{q 2^t} \log n$, which is a polynomial in $n$.
  Hence there are a polynomial number of simulations of $V$ running in parallel.
  Since $V$ has polynomial size and polynomials are closed under multiplication, $M$ also has polynomial size.
  Since each simulation of $V$ is run in parallel, the depth of $M$ in this phase equals the polylogarithmic depth of $V$.
  Computing the majority of a polynomial number of bits can be done in polynomial size and logarithmic depth \cite[Theorem~2.6.1]{savage98}, so the overall circuit is polynomial in size and polylogarithmic in depth.

  Now we show the correctness of $M$.
  If $x \in L$, then all instances of $V$ accept, so certainly at least half of the instances of $V$ accept, and hence $M$ accepts.
  If $x \notin L$, then fewer than half of the instances of $V$ accept, so $M$ rejects.
  Therefore we have shown that $M$ is a correct \NC{} algorithm for $L$.
\end{proof}

From \autoref{lem:derandomize} and \autoref{lem:pcpinnnc}, we find the following.

\begin{theorem}\label{thm:ncpcp}
  $\NC = \PCP^\NC[O(\loglog n), O(1)]$.
\end{theorem}

\subsection{Restricted PCP characterization of \texorpdfstring{\NP}{NP}}

The idea for showing $\PCP^\NC[O(\log n), O(1)] = \NP$ is to revisit a proof of the PCP Theorem and ensure that all computation can be performed by an \NC{} PCP verifier without affecting the correctness of the proof.
We will consider Dinur's proof of the PCP Theorem \cite{dinur07}, which reduces the problem of proving $\PCP^\P[O(\log n), O(1)] = \NP$ to the problem of showing \textsc{$\frac{1}{2}$-gap $q$-CSP} is hard for \NP.
We begin with the \NC{} version of this reduction.

\begin{lemma}\label{lem:inapprox}
  If there is a positive integer $q$ such that \textsc{$\frac{1}{2}$-gap $q$-CSP} is hard for \NP{} under \NC{} many-one reductions, then $\PCP^\NC[O(\log n), O(1)] = \NP$.
\end{lemma}
\begin{proof}
  One inclusion in the conclusion of the theorem is true unconditionally, following from the PCP Theorem \cite{almss98}.
  For the other inclusion, let $L$ be a language in \NP.
  By hypothesis there exists many-one reduction computable in \NC{} from $L$ to \textsc{$\frac{1}{2}$-gap $q$-CSP}.
  We construct the PCP verifier as follows.
  \begin{enumerate}
  \item Compute the reduction to produce a set of constraints.
  \item Use $O(\log n)$ random bits to choose a constraint uniformly at random.
  \item Check that the constraint is satisfied by querying the proof string at the appropriate locations (the locations corresponding to the $q$ variables in the constraint).
  \end{enumerate}

  If $x \in L$ then all constraints are satisfiable, so there exists an assignment such that the verifier will accept on all random choices of the constraint.
  If $x \notin L$ then fewer than half of the constraints are satisfiable, so for any assignment the probability that the verifier will select a satisfied constraint is less than half.
  Therefore we have shown a correct PCP verifier with the appropriate parameters for an arbitrary language in \NP.
\end{proof}

Now we examine Dinur's proof that \textsc{$\frac{1}{2}$-gap $q$-CSP} is hard for \NP.
\textbf{TODO complete the analysis...}

From \autoref{lem:inapprox} and \autoref{lem:reduction}, we have the following.

\begin{theorem}\label{thm:pcpnp}
  $\PCP^\NC[O(\log n), O(1)] = \NP$.
\end{theorem}

\section{About this work}

Copyright 2013 Jef{}frey Finkelstein.

This work is licensed under the Creative Commons Attribution-ShareAlike License 3.0.
Visit \mbox{\url{https://creativecommons.org/licenses/by-sa/3.0/}} to view a copy of this license.

The \LaTeX{} markup which generated this document is available on the World Wide Web at \mbox{\url{https://github.com/jfinkels/ncpcp}}.
It is also licensed under the Creative Commons Attribution-ShareAlike License.

The author can be contacted via email at \email{jeffreyf@bu.edu}.

\bibliographystyle{plain}
\bibliography{references}

\end{document}
