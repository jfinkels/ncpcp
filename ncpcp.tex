\documentclass[draft]{article}

% Package `amsthm` and `thmtools` must come before package `hyperref`.
\usepackage{amsthm}
\usepackage{thmtools}
% Package `hyperref` must come before package `complexity`.
\usepackage[pdftitle={Restricted probabilistically checkable proofs}, pdfauthor={Jeffrey Finkelstein}]{hyperref}
\usepackage{complexity}
\usepackage{amsmath}
\usepackage{amssymb}

\declaretheorem[numberwithin=section]{theorem}
\declaretheorem[numberlike=theorem]{corollary}
\declaretheorem[numberlike=theorem]{lemma}
\declaretheorem[numberlike=theorem]{proposition}
\declaretheorem[numberlike=theorem, style=definition]{definition}

%% Arguments:
%%  1. Complexity class of the verifier
%%  2. Completeness probability
%%  3. Soundness probability
%%  4. Randomness
%%  5. Number of queries
\newcommand{\PCPcs}[5]{\PCP^{#1}_{#2, #3}\left[#4, #5\right]}
\newcommand{\lglg}{\lg\lg}

\newenvironment{proofidea}{\begin{proof}[Proof~idea]}{\end{proof}}

\title{Restricted probabilistically checkable proofs}
\author{Jef{}frey~Finkelstein}
\date{\today}

\begin{document}
\maketitle

\section{Preliminaries}

\begin{definition}
  For all functions $f, g \colon \mathbb{N} \to \mathbb{R}$, the function $f$ is in the class $O(g(n))$ if there exist real numbers $c$ and $N$ such that for all natural numbers $n$ we have $n > N$ implies $f(n) \leq c \cdot g(n)$.
  If $f(n) < c \cdot g(n)$ then $f(n)$ is in $o(g(n))$.
\end{definition}

\begin{definition}[{{\cite[Definition~1.1]{dinur07}}}]
  Let $V$ be a finite set of variables, defined by $V = \{x_1, x_2, \dotsc, x_n\}$, let $\Gamma$ be a finite alphabet, and let $q$ be a natural number.
  A \emph{$q$-ary constraint} is a $q + 1$ tuple, $(C, i_1, i_2, \dotsc, i_q)$, where $C \subseteq \Gamma^q$ and $i_k \in \{1, 2, \dotsc, n\}$ for all $k \in \{1, 2, \ldots, q\}$.
  Here, $C$ is considered the set of ``acceptable'' values for the variables.

  An \emph{assignment} is a function $a \colon V \to \Gamma$.
  An assignment \emph{satisfies} a constraint if $(a(v_{i_1}), a(v_{i_2}), \dotsc, a(v_{i_q})) \in C$.
\end{definition}

\begin{definition}
  Suppose $D$ is a collection of constraints over the set of variables $V$.
  Let $A$ represent the set of all assignments to $V$.
  The \emph{satisfiability fraction} of a collection of constraints, denoted $\SAT(D)$, is defined by
  \begin{equation*}
    SAT(D) = \max_{a \in A}{\frac{\left|\left\{ C_i \in D \, \middle| \, a \text{ satisfies } C_i \right\}\right|}{\left|D\right|}}.
  \end{equation*}
\end{definition}

\begin{definition}[\textsc{Constraint Satisfaction Problem} (or \textsc{CSP})]
  \mbox{}

  \textbf{Instance:} finite alphabet $\Gamma$ with $|\Gamma| > 1$, finite set of variables $V$, finite set of constraints $D$.

  \textbf{Question:} Are all constraints in $D$ satisfiable?
\end{definition}

In the following definitions, let $q$ be a fixed natural number greater than 1.

\begin{definition}[\textsc{$q$-CSP}]
  \mbox{}

  \textbf{Instance:} finite alphabet $\Gamma$ with $|\Gamma| > 1$, finite set of variables $V$, finite set of $q$-ary constraints $D$.

  \textbf{Question:} Are all constraints $D$ satisfiable?
\end{definition}

\begin{definition}[\textsc{$\epsilon$-gap $q$-CSP}]
  \mbox{}

  \textbf{Instance:} finite alphabet $\Gamma$ with $|\Gamma| > 1$, finite set of variables $V$, finite set of $q$-ary constraints $D$ with the restriction that either $SAT(D) < \frac{1}{2}$ or $SAT(D) = 1$.

  \textbf{Question:} Are all constraints in $D$ satisfiable?
\end{definition}

\begin{definition}
  A \emph{\PCP{} verifier} is a probabilistic Turing machine which has sequential access to an input string $x$, sequential access to a random string $\rho$, and \emph{nonadaptive random access} to a proof string $\pi$.
\end{definition}

\begin{definition}
  For all natural numbers $a$ and $b$, a language $L$ has a $(a \cdot r(n), b \cdot q(n))$-\emph{$\PCP_{c(n), s(n)}$ verifier} if there exists a \PCP{} verifier $V$ such that $V$ uses at most $a \cdot r(n)$ bits of the random string $\rho$, $V$ makes at most $b \cdot q(n)$ \emph{nonadaptive} queries to bits of the proof $\pi$, and the following conditions hold
  \begin{enumerate}
  \item if $x \in L$, then 
    \begin{equation*}
      \exists \pi \in \Sigma^{a \cdot r(n) + \lg{b \cdot q(n)}} \colon \Pr_{\rho \in \Sigma^{a \cdot r(n)}}{\left[V(x, \pi; \rho) \textnormal{ accepts}\right]} >= c(n),
    \end{equation*}
    and
  \item if $x \notin L$, then
    \begin{equation*}
      \forall \pi \in \Sigma^{a \cdot r(n) + \lg{b \cdot q(n)}} \colon \Pr_{\rho \in \Sigma^{a \cdot r(n)}}{\left[V(x, \pi; \rho) \textnormal{ accepts}\right]} < s(n).
    \end{equation*}
  \end{enumerate}
\end{definition}

A verifier which uses $q$ adaptive random access queries to the proof string can be simulated by a verifier which uses $2^q$ nonadaptive random access queries to the proof string.
The total number of queried bits of the proof string for an \emph{adaptive} $(a \cdot r(n), b \cdot q(n))$-\PCP{} verifier is $a \cdot r(n) + b \cdot q(n)$ and for a \emph{nonadaptive} \PCP{} verifier, $a \cdot r(n) + \lg{b \cdot q(n)}$.
In this work, we will consider only nonadaptive \PCP{} verifiers; for nonadaptive \PCP{} verifiers there are $2^{a \cdot r(n) + \lg{b \cdot q(n)}}$ possible proof strings, or more simply $2^{a \cdot r(n)} \cdot b \cdot q(n)$.

\begin{definition}
  Let $\PCPcs{\mathcal{C}}{c(n)}{s(n)}{a \cdot r(n)}{b \cdot q(n)}$ be the class of all languages $L$ such that $L$ has a $(a \cdot r(n), b \cdot q(n))$-$\PCP_{c(n), s(n)}$ verifier $V$ computable by a $\mathcal{C}$ algorithm.

  More generally, if $\mathcal{F}$ and $\mathcal{G}$ are classes of functions,
  \begin{equation*}
    \PCPcs{\mathcal{C}}{c(n)}{s{n}}{\mathcal{F}}{\mathcal{G}} = \bigcup_{f \in \mathcal{C}, g \in \mathcal{G}}{\PCPcs{\mathcal{C}}{c(n)}{s(n)}{f(n)}{g(n)}},
    \end{equation*}
\end{definition}

From the definition, we see immediately that
\begin{equation*}
  \PCPcs{\mathcal{C}}{c(n)}{s{n}}{O(r(n))}{O(q(n))} = \bigcup_{a \in \mathbb{N}, b \in \mathbb{N}}{\PCPcs{\mathcal{C}}{c(n)}{s(n)}{a \cdot r(n)}{b \cdot q(n)}}.
\end{equation*}

\section{The PCP Theorem}

The celebrated ``PCP Theorem'' can be stated as follows.
\begin{theorem}
  $\NP = \PCPcs{\P}{1}{\frac{1}{2}}{O(\lg n)}{O(1)}$.
\end{theorem}
The proof has two parts, one easy and one hard.
The following lemma proves the easy part.
\begin{lemma}\label{lem:pcpinnp}
  $\PCPcs{\P}{1}{\frac{1}{2}}{O(\lg n)}{O(1)} \subseteq \NP$.
\end{lemma}
\begin{proof}
  Let $L \in \PCPcs{\P}{1}{\frac{1}{2}}{O(\lg n)}{O(1)}$, so there exists a polynomial time \PCP{} verifier $V$ subject to the appropriate restrictions.
  Construct a nondeterministic Turing machine $N$ as follows.

  On input $x$, nondeterministically guess a proof string $\pi$ of length $r \lg n + \lg q$, where $q$ and $r$ are the appropriate constants for the language $L$.
  Enumerate each ``random'' string $\rho$ of length $r \lg  n$, and for each $\rho$, simulate $V$ on input $x$, proof string $\pi$, and random string $\rho$.
  If $V$ accepts in at least half of the simulations, then accept; otherwise reject.

  This machine uses a polynomial amount of nondeterminism, runs in polynomial time (due to the fact that $V$ runs in polynomial time, and counting the number of accepting simulations can also be performed efficiently) and accepts exactly when at least half of the instances of $V(x, \pi; \rho)$ accept.
  Therefore $x \in L$ if and only $N$ accepts $x$, and we have $L \in \NP$.  
\end{proof}

The hard part uses the following ``inapproximability'' view of the PCP Theorem.
\begin{proposition}[{{\cite[Theorem~1.3]{dinur07}}}]
  The following are equivalent.
  \begin{enumerate}
  \item $\NP \subseteq \PCPcs{\P}{1}{\frac{1}{2}}{O(\lg n)}{O(1)}$.
  \item There exists an integer $q$, with $q > 1$, such that \textsc{$\frac{1}{2}$-gap $q$-CSP} is \NP-hard.
  \end{enumerate}
\end{proposition}
\begin{proofidea}
  \mbox{}
  \begin{enumerate}
  \item ($1 \implies 2$) Construct a set of constraints using the Cook-Levin reduction where each constraint is satisfied exactly when the \PCP{} verifier accepts.
  \item ($2 \implies 1$)
    The \PCP{} verifier computes the reduction from an arbitrary \NP{} language to \textsc{$\frac{1}{2}$-gap $q$-CSP}, uses its randomness to select a constraint uniformly at random, then queries the proof string in the corresponding locations, accepting if and only if the proof string reflects a satisfying assignment.
  \end{enumerate}
\end{proofidea}
With this equivalence, we can reduce the problem of showing that $\NP \subseteq \PCPcs{\P}{1}{\frac{1}{2}}{O(\lg n)}{O(1)}$ to the problem of showing that \textsc{$\frac{1}{2}$-gap $q$-CSP} is \NP-hard.
In \cite{dinur07}, the author solves the latter problem using an almost entirely combinatoric technique (we conjecture that an entirely combinatoric proof exists).

One of our goals is to characterize smaller complexity classes using more restrictive \PCP{} classes.
We hope to use such a characterization for applications to inapproximability in the realm of optimization problems whose corresponding decision problems are \P-complete, but which admit a ``good'' highly parallel approximation.
In this work, ``highly parallel'' algorithms are implementable by \NC{} circuit families.
A \P-complete problem, that is, a problem for which no highly parallel algorithm exists unless $\P = \NC$, is called ``inherently sequential''.

In order to utilize the proof techniques from the \NP{} version of the \PCP{} Theorem, we consider a nondeterministic generalization of \NC.
\begin{definition}
  A \emph{nondeterministic gate} (or \emph{guess gate}) in a Boolean circuit is a gate with no inputs and one output.
  A language $L$ is in $\NNC(f(n))$ if there exists an \NC{} circuit family $\left\{C_n\right\}_{n \in \mathbb{N}}$, each circuit $C_n$ augmented with $O(f(n))$ nondeterministic guess gates, such that $x \in L$ if and only if $C_n(x)$ accepts.

  Alternatively a language $L$ is in $\NNC(f(n))$ if there exists an \NC{} circuit family $\left\{C_n\right\}_{n \in \mathbb{N}}$ such that $x \in L$ if and only if there exists a witness $\pi$ of length $c \cdot f(x)$ for some constant $c$ such that $C_{n + c \cdot f(x)}(x, \pi)$ outputs 1.
\end{definition}

\begin{proposition}[\cite{wolf94}]\label{prop:nnc}
  \mbox{}
  \begin{enumerate}
  \item $\NNC(\lg n) = \NC$.
  \item $\NNC(\poly) = \NP$.
  \end{enumerate}
\end{proposition}

Following the proof of \autoref{lem:pcpinnp}, we can show the following inclusion.
\begin{proposition}\label{lem:pcpinnnc}
  $\PCPcs{\NC^k}{1}{\frac{1}{2}}{r \lg \lg n}{O(\lg^j n)} \subseteq \NNC^k(\lg^{j + r} n)$ for all constants $r$, $k$, and $j$.
\end{proposition}
\begin{proof}
  Let $L \in \PCPcs{\NC^k}{1}{\frac{1}{2}}{r \lg \lg n)}{O(\lg^j n)}$, so there exists an $\NC^k$ \PCP{} verifier $V$ subject to the appropriate restrictions.
  Construct an $\NNC^k(\lg^{j + r} n)$ algorithm as follows.

  \textbf{TODO fill me in}
\end{proof}

\begin{corollary}
  \mbox{}
  \begin{enumerate}
  \item $\PCPcs{\NC}{1}{\frac{1}{2}}{O(\lg \lg n)}{O(\polylog)} \subseteq \NNC(\polylog) = \NP$.
  \item $\PCPcs{\NC^k}{1}{\frac{1}{2}}{0}{O(\lg n)} \subseteq \NNC(\lg n) = \NC$ for all $k \in \mathbb{N}$.
  \item $\PCPcs{\NC^k}{1}{\frac{1}{2}}{r \lg \lg n}{O(1)} \subseteq \NNC(\lg n) = \NC$ for all $k \in \mathbb{N}$.
  \end{enumerate}
\end{corollary}

\bibliographystyle{plain}
\bibliography{references}

\end{document}
