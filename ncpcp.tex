\documentclass{article}

% Package `amsthm` and `thmtools` must come before package `hyperref`.
\usepackage{amsthm}
\usepackage{thmtools}
% Package `hyperref` must come before package `complexity`.
\usepackage[pdftitle={Restricted probabilistically checkable proofs}, pdfauthor={Jeffrey Finkelstein}]{hyperref}
\usepackage{complexity}
\usepackage{amsmath}
\usepackage{amssymb}

\declaretheorem[numberwithin=section]{theorem}
\declaretheorem[numberlike=theorem]{corollary}
\declaretheorem[numberlike=theorem]{lemma}
\declaretheorem[numberlike=theorem]{proposition}
\declaretheorem[numberlike=theorem, style=definition]{construction}
\declaretheorem[numberlike=theorem, style=definition]{definition}

%% Arguments:
%%  1. Complexity class of the verifier
%%  2. Completeness probability
%%  3. Soundness probability
%%  4. Randomness
%%  5. Number of queries
\newcommand{\PCPcs}[5]{\PCP^{#1}_{#2, #3}\left[#4, #5\right]}
\newcommand{\loglog}{\log \log}
\newcommand{\email}[1]{\href{mailto:#1}{\nolinkurl{#1}}}

\newenvironment{proofidea}{\begin{proof}[Proof~idea]}{\end{proof}}

\title{Restricted probabilistically checkable proofs}
\author{Jef{}frey~Finkelstein}
\date{\today}

\begin{document}
\maketitle

\section{Introduction}

In this work we provide some initial structural complexity results for classes of probabilistically checkable proof systems (PCPs) for nondeterministic \NC{} (\NNC) circuit families, as a first step towards characterizing probabilistic proof systems for \P.
One of the major successes of the characterization of \NP{} as a class of PCPs (with polynomial time verifiers) is that it provides a route to proving that approximating certain computationally intractable optimization problems is as difficult as solving them exactly.
The growth of multiprocessor systems in general purpose personal computers highlights the urgency of proving the analagous inapproximability (or approximability) of \emph{inherently sequential} optimization problems by \emph{highly parallel} algorithms.
The \P-complete problems are generally considered to be inherently sequential, whereas problems in \NC{} are considered highly parallel.
Our guiding question is now, ``For which \P-complete problems are there \NC{} approximation algorithms, and for which are there none?''

Unfortunately, the techniques used to prove the original PCP Theorem rely on the fact that \NP{} can be interpreted as the class of languages for which there is an efficient verification procedure given a brief witness to language membership; no such obvious interpretation of \P{} exists.
Indeed, this question was already on the minds of researchers soon after the original proof of the PCP Theorem.
\begin{quote}
  An intriguing question is whether the known non-approximability results for sequential algorithms can be improved when we restrict to \NC{} algorithms (under the assumption that $\P \neq \NC$).
  A possible way may be to devise \emph{probabilistic proof systems for \P} more efficient that the currently known proof systems for \NP.
  Such a result would have a great independent interest.
  However, it is not clear why proofs for \P{} should be \emph{easier to check} than proofs for \NP{} (they only appear to be \emph{easier to generate}). \cite{trevisan98}
\end{quote}
Perhaps \P{} has proof systems which are easy to check in \NC, but this remains unclear.
Instead, we consider proof systems for the class $\NNC(\polylog)$, the class of languages decidable by \NC{} circuit families augmented with a polylogarithmic number of nondeterministic gates.
We hope that this will be a valuable first step toward understanding proof systems for \P.
We consider $\NNC(\polylog)$ for two reasons.
First, it is defined in such a way that it explicitly has short proof systems which are easy to verify in parallel, just as \NP{} is defined in such a way that it explicitly has short proof systems which are easy to verify efficiently.
Second, it, like \P, lies between \NC{} and \NP{}.

Although our original intention was to show a result like $\NNC(\polylog) = \PCP[O(\loglog n), O(1)]$, our research reveals that proving such an equality is equivalent to proving $\NNC(\polylog) = \NC$, or in other words, that a polylogarithmic amount of nondeterminism can be simulated deterministically by an \NC{} circuit family.
This should be seen as evidence that such a result is unlikely; in fact, we show that such a simulation implies a deterministic subexponential time algorithm for \textsc{Satisfiability}!
We are still, however, able to show that certain PCP classes are contained in $\NNC(\polylog)$.

\section{Preliminaries}

Throughout this work, $\log n$ denotes the base 2 logarithm of $n$.

We assume the reader knows the basic definitions from complexity theory, including those of the complexity classes \P, \NP, \DTIME, and \DSPACE.
We define the complexity class \SUBEXP{}, the class of languages decidable by deterministic ``subexponential'' time Turing machines, as
\begin{equation*}
  \SUBEXP = \cap_{\epsilon > 0} \DTIME(2^{n^\epsilon})
\end{equation*}
and \QP{}, the class of languages decidable by a deterministic ``quasipolynomial'' time Turing machine, as
\begin{equation*}
  \QP = \cup_{k \in \mathbb{N}} \DTIME(2^{\log^k n}).
\end{equation*}
We will also be considering $\NC^k$, the class of languages decidable by a family of logarithmic space uniform Boolean circuits of polynomial size, $O(\log^k n)$ depth, and unbounded fan-in.
We will denote by $\NC$ the union of all the $\NC^k$ classes.

\begin{definition}
  For all functions $f, g \colon \mathbb{N} \to \mathbb{R}$, the function $f$ is in the class $O(g(n))$ if there exist real numbers $c$ and $N$ such that for all natural numbers $n$ we have $n > N$ implies $f(n) \leq c \cdot g(n)$.
  If $f(n) < c \cdot g(n)$ then $f(n)$ is in $o(g(n))$.
  If $f(n) \geq c \cdot g(n)$ then $f(n)$ is in $\Omega(g(n))$.
  If $f(n) > c \cdot g(n)$ then $f(n)$ is in $\omega(g(n))$.
\end{definition}

\begin{definition}[{{\cite[Definition~1.1]{dinur07}}}]
  Let $V$ be a finite set of variables, defined by $V = \{x_1, x_2, \dotsc, x_n\}$, let $\Gamma$ be a finite alphabet, and let $q$ be a natural number.
  A \emph{$q$-ary constraint} is a $q + 1$ tuple, $(C, i_1, i_2, \dotsc, i_q)$, where $C \subseteq \Gamma^q$ and $i_k \in \{1, 2, \dotsc, n\}$ for all $k \in \{1, 2, \ldots, q\}$.
  Here, $C$ is considered the set of ``acceptable'' values for the variables.

  An \emph{assignment} is a function $a \colon V \to \Gamma$.
  An assignment \emph{satisfies} a constraint if $(a(v_{i_1}), a(v_{i_2}), \dotsc, a(v_{i_q})) \in C$.
\end{definition}

\begin{definition}[\textsc{$\frac{1}{2}$-gap $q$-CSP}]
  \mbox{}

  \textbf{Instance:} finite alphabet $\Gamma$ with $|\Gamma| > 1$, finite set of variables $V$, finite set of $q$-ary constraints $D$ with the restriction that for any assignment, either all constraints are satisfied or fewer than half are.

  \textbf{Question:} Are all constraints in $D$ satisfiable?
\end{definition}

\begin{definition}
  A \emph{PCP verifier} is a probabilistic Turing machine which has sequential access to an input string $x$, sequential access to a random string $\rho$, and \emph{nonadaptive random access} to a proof string $\pi$.
\end{definition}

The initialism ``PCP'' stands for ``probabilistically checkable proof''.

\begin{definition}
  Let $r(n)$ and $q(n)$ be bounded above by polynomials in $n$, and let $c(n)$ and $s(n)$ be functions whose values are in the interval $[0, 1]$.
  A language $L$ has a $(r(n), q(n), c(n), s(n))$-\emph{PCP verifier} if there exists a PCP verifier $V$ such that $V$ uses at most $r(n)$ bits of the random string $\rho$, makes at most $q(n)$ \emph{nonadaptive} queries to bits of the proof $\pi$, and satisfies the following conditions.
  \begin{enumerate}
  \item If $x \in L$, then
    \begin{equation*}
      \exists \pi \in \Sigma^* \colon \Pr_{\rho \in \Sigma^{r(n)}}{\left[V(x, \pi; \rho) \textnormal{ accepts}\right]} \geq c(n).
    \end{equation*}
  \item If $x \notin L$, then
    \begin{equation*}
      \forall \pi \in \Sigma^* \colon \Pr_{\rho \in \Sigma^{r(n)}}{\left[V(x, \pi; \rho) \textnormal{ accepts}\right]} < s(n).
    \end{equation*}
  \end{enumerate}
  The value $c(n)$ is the \emph{completeness} and the value $s(n)$ the \emph{soundness} of the verifier.
\end{definition}

In this work, we will consider only nonadaptive PCP verifiers.
Since a (nonadaptive) $(r(n), q(n), c(n), s(n))$-PCP verifier can read at most $2^{r(n)} q(n)$ locations of the proof string with nonzero probability, we assume without loss of generality that the proof provided to the verifier is of length at most $2^{r(n)} q(n)$ \cite[Remark~11.6]{ab09}.
(Note that a verifier which uses $q(n)$ adaptive random access queries to the proof string can be simulated by a verifier which uses $2^{q(n)}$ nonadaptive random access queries to the proof string, so in the adaptive case, the proof string could be of length $2^{r(n) + q(n)}$.)

\begin{definition}
  Let $\PCPcs{\mathcal{C}}{c(n)}{s(n)}{r(n)}{q(n)}$ be the class of all languages $L$ such that $L$ has a $(r(n), q(n), c(n), s(n))$-PCP verifier $V$ computable by a $\mathcal{C}$ algorithm.

  More generally, if $\mathcal{F}$ and $\mathcal{G}$ are classes of functions,
  \begin{equation*}
    \PCPcs{\mathcal{C}}{c(n)}{s(n)}{\mathcal{F}}{\mathcal{G}} = \bigcup_{f \in \mathcal{C}, g \in \mathcal{G}}{\PCPcs{\mathcal{C}}{c(n)}{s(n)}{f(n)}{g(n)}},
    \end{equation*}

  Since completeness 1 and soundness $\frac{1}{2}$ are common parameters, and for the sake of brevity, we write $\PCP^{\mathcal{C}}[r(n), q(n)]$ to denote $\PCPcs{\mathcal{C}}{1}{\frac{1}{2}}{r(n)}{q(n)}$, and $\PCP^{\mathcal{C}}[\mathcal{F}, \mathcal{G}]$ to denote $\PCPcs{\mathcal{C}}{1}{\frac{1}{2}}{\mathcal{F}}{\mathcal{G}}$.
\end{definition}

Please notice that the complexity class given in the superscript in the above definition does \emph{not} denote an oracle; it merely describes the computational power of the PCP verifier.

From the definition, we see immediately that
\begin{equation*}
  \PCPcs{\mathcal{C}}{c(n)}{s{n}}{O(r(n))}{O(q(n))} = \bigcup_{a \in \mathbb{N}, b \in \mathbb{N}}{\PCPcs{\mathcal{C}}{c(n)}{s(n)}{a \cdot r(n)}{b \cdot q(n)}}.
\end{equation*}

\section{Probabilistically checkable proofs for nondeterministic circuits}

First, consider the chain of inclusions
\begin{equation*}
  \NNC(\log n) \subseteq \NNC(\polylog) \subseteq \NNC(\poly).
\end{equation*}
In fact, $\NC = \NNC(\log n)$ and $\NNC(\poly) = \NP$ \cite{wolf94}, so we can rewrite this as
\begin{equation}\label{eq:chain}
  \NC \subseteq \NNC(\polylog) \subseteq \NP.
\end{equation}
We will show that $\NC = \PCP^\NC[O(\loglog n), O(1)]$ and $\PCP^\NC[O(\log n), O(1)] = \NP$, which together yield
\begin{equation}\label{eq:pcpchain}
  \PCP^\NC[O(\loglog n), O(1)] \subseteq \NNC(\polylog) \subseteq \PCP^\NC[O(\log n), O(1)].
\end{equation}
We first provide evidence that the inclusions in \autoref{eq:chain} are strict.
From this and \autoref{eq:pcpchain}, we will infer that any restricted PCP characterization (with a constant number of proof queries) of $\NNC(\polylog)$ likely requires PCP verifiers that use $\omega(\loglog n)$ bits and $o(\log n)$ bits of randomness. Note that \P{} can replace $\NNC(\polylog)$ in any of the above inclusion chains, so the same conclusion holds for \P.
(On the other hand, it is conjectured that \P{} and $\NNC(\polylog)$ are incomparable \cite{wolf94}.)

\begin{theorem}
  \mbox{}
  \begin{enumerate}
  \item If $\NC = \NNC(\polylog)$, then $\NP \subseteq \SUBEXP$.
  \item If $\NNC(\polylog) = \NP$, then $\NP \subseteq \QP$.
  \end{enumerate}
\end{theorem}
\begin{proof}
  If $\NNC(\polylog) = \NP$, then
  \begin{align*}
    \NP & \subseteq \NNC(\polylog) \\
        & \subseteq \DSPACE(\polylog) & \text{(by \cite{wolf94})} \\
        & \subseteq \DTIME(2^{\polylog}) & \text{(by exhaustive search)} \\
        & = \QP & \text{(by definition)}.
  \end{align*}
  Now suppose $\NC = \NNC(\polylog)$.
  Since \textsc{Satisfiability} is complete for $\NP$ under deterministic polynomial time many-one reductions, it suffices to show a deterministic subexponential time algorithm for \textsc{Satisfiability}.

  The proof uses a padding argument.
  First we observe that there is an $\NNC^1(n)$ machine, call it $M$, that decides \textsc{Satisfiability}: given a Boolean formula $\phi$, guess a satisfying assignment to $\phi$ (of length $O(n)$) and evaluate the formula (Boolean formula evaluation is in $\NC^1$ \cite{buss87}).
  Let $\epsilon$ be an arbitrarily small positive constant, and define $L$, the padded version of \textsc{Satisfiability}, as
  \begin{equation*}
    L = \left\{ \phi \# 1^P \, \middle| \, \phi \in \textsc{Satisfiability} \text{ and } P = 2^{n^\epsilon} - (n + 1) \right\},
  \end{equation*}
  where $n = |\phi|$.
  We claim $L$ is in $\NNC(\log^\frac{1}{\epsilon} n)$ by the following machine, $M_j$.
  On input $\phi'$, check that $\phi'$ is in the format $\phi \# 1^P$, then accept if and only if $M$ accepts $\phi$.
  The correctness of this algorithm follows from the correctness of $M$, so it remains to check the size and depth of the circuit for $M_j$, and the amount of nondeterminism used.

  Checking that $x'$ is in the correct format can be performed (deterministically) by an $\NC^0$ circuit by computing the conjunction of all the bits after the $\#$ symbol.
  Observe now that $|x'| = 2^{n^\epsilon}$, so $n = \log^\frac{1}{\epsilon}{|x'|}$.
  The amount of nondeterminism used by $M_j$ is the same as the amount used by $M$, which is $O(n)$, or $O(\log^\frac{1}{\epsilon} |x'|)$.
  The size of $M$ is polynomial in $n$, which is polylogarithmic in $|x'|$, and hence polynomial in the length of the input $x'$.
  The depth of $M$ is $O(\log n)$, which is $O(\log \log^\frac{1}{\epsilon} |x'|)$, or simply $O(\log \log |x'|)$.
  We conclude that the size of $M_j$ is polynomial in $|x'|$, the depth of $M_j$ is logarithmic in $|x'|$, and $M_j$ uses $O(\log^\frac{1}{\epsilon} |x'|)$ bits of nondeterminism.
  Hence $L$ is in $\NNC(\log^\frac{1}{\epsilon} n)$.

  By hypothesis, $L$ is also in $\NC$.
  Let $M_i$ be the $\NC$ machine that decides it.
  We claim that we can now construct a subexponential time algorithm for \textsc{Satisfiability} on inputs $\phi$ of length $n$.
  \begin{enumerate}
  \item Let $\phi' = \phi \# 1^P$, where $P = 2^{n^\epsilon} - (n + 1)$.
  \item Accept if and only if $M_i$ accepts $\phi'$.
  \end{enumerate}
  The correctness of this algorithm follows immediately from the correctness of $M_i$.
  The first step can be performed by a deterministic algorithm running in time $2^{n^\epsilon}$.
  The second step can be performed by an $\NC$ machine.
  Since $\NC \subseteq \P$, and $2^{n^\epsilon}$ is greater than any polynomial for sufficiently large $n$, the first step is the bottleneck in this algorithm.
  Therefore, this algorithm for \textsc{Satisfiability} can be implemented by a deterministic algorithm running in $O(2^{n^\epsilon})$ time for arbitrarily small $\epsilon$.
\end{proof}

Intuitively, this theorem states that the difference in complexity between languages in $\NC$ and languages in $\NNC(\polylog)$ is smaller than the difference in complexity between languages in $\NNC(\polylog)$ and languages in $\NP$.
This makes sense: the ``difference'' between $\log n$ and a polynomial in $\log n$ is less than the ``difference'' a polynomial in $n$ and a polynomial in $\log n$.

Next we turn to the restricted PCP characterizations for \NC{} and \NP{}.
In \cite{fs96}, the authors prove that $\P = \PCP^\P[O(\loglog n), O(1)]$ (implicitly; they actually prove that $\NP = \PCP^\P[O(\loglog n), O(1)]$ if and only if $\P = \NP$).
The same proof techniques can be used in the \NC{} setting with essentially no changes.
(The idea of the proof is to simulate $O(\loglog n)$ bits of randomness with $\loglog n + O(1)$ bits by making a random walk of an appropriate length on a fully explicit constant degree expander graph.)

\begin{theorem}\label{thm:ncpcp}
  $\NC = \PCP^\NC[O(\loglog n), O(1)]$.
\end{theorem}

The idea for showing $\PCP^\NC[O(\log n), O(1)] = \NP$ is to revisit a proof of the PCP Theorem and ensure that all computation can be performed by an \NC{} PCP verifier without affecting the correctness of the proof.
We will consider Dinur's proof of the PCP Theorem \cite{dinur07}, which reduces the problem of proving $\PCP^\P[O(\log n), O(1)] = \NP$ to the problem of showing \textsc{$\frac{1}{2}$-gap $q$-CSP} is hard for \NP.
We begin with the \NC{} version of this reduction.

\begin{lemma}\label{lem:inapprox}
  If there is a positive integer $q$ such that \textsc{$\frac{1}{2}$-gap $q$-CSP} is hard for \NP{} under logarithmic space many-one reductions, then $\PCP^\NC[O(\log n), O(1)] = \NP$.
\end{lemma}
\begin{proof}
  One inclusion in the conclusion of the theorem is true unconditionally, following from the PCP Theorem \cite{almss92}.
  For the other inclusion, let $L$ be a language in \NP.
  By hypothesis there exists many-one reduction computable in logarithmic space from $L$ to \textsc{$\frac{1}{2}$-gap $q$-CSP}.
  We construct the PCP verifier as follows.
  \begin{enumerate}
  \item Compute the reduction to produce a set of constraints.
  \item Use $O(\log n)$ random bits to choose a constraint uniformly at random.
  \item Check that the constraint is satisfied by querying the proof string at the appropriate locations (the locations corresponding to the $q$ variables in the constraint).
  \end{enumerate}

  If $x \in L$ then all constraints are satisfiable, so there exists an assignment such that the verifier will accept on all random choices of the constraint.
  If $x \notin L$ then fewer than half of the constraints are satisfiable, so for any assignment the probability that the verifier will select a satisfied constraint is less than half.
  Therefore we have shown a correct PCP verifier with the appropriate parameters for an arbitrary language in \NP.
\end{proof}

Now we examine Dinur's proof that \textsc{$\frac{1}{2}$-gap $q$-CSP} is hard for \NP.

\begin{lemma}\label{lem:reduction}
  There is a positive integer $q$ such that \textsc{$\frac{1}{2}$-gap $q$-CSP} is hard for \NP{} under logarithmic space many-one reductions.
\end{lemma}
\textbf{TODO complete the analysis...}

From \autoref{lem:inapprox} and \autoref{lem:reduction}, we have the following.

\begin{theorem}\label{thm:pcpnp}
  $\PCP^\NC[O(\log n), O(1)] = \NP$.
\end{theorem}

\section{About this work}

Copyright 2013 Jef{}frey Finkelstein.

This work is licensed under the Creative Commons Attribution-ShareAlike License 3.0.
Visit \mbox{\url{https://creativecommons.org/licenses/by-sa/3.0/}} to view a copy of this license.

The \LaTeX{} markup which generated this document is available on the World Wide Web at \mbox{\url{https://github.com/jfinkels/ncpcp}}.
It is also licensed under the Creative Commons Attribution-ShareAlike License.

The author can be contacted via email at \email{jeffreyf@bu.edu}.

\bibliographystyle{plain}
\bibliography{references}

\end{document}
